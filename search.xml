<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android插件化基本流程]]></title>
    <url>%2F2019%2F05%2F08%2FAndroid%E6%8F%92%E4%BB%B6%E5%8C%96%E5%9F%BA%E6%9C%AC%E6%B5%81%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[插件化主要功能 实现宿主程序调用插件中类方法的功能 实现宿主程序获取插件中资源文件的功能 实现宿主程序渲染插件中layout布局的功能 该篇暂未涉及到四大组件 加载插件中的类文件 通多DexClassLoader加载器加载产检中的dex文件，相关文档可参考 Android解析ClassLoader 1234//加载apk，生成对应的ClassLoaderDexClassLoader bundleDexClassLoader = new DexClassLoader(f.getAbsolutePath(), dexDir.getAbsolutePath(), null, context.getClassLoader().getParent()); 加载插件中的资源文件 Android中是通过Resources、AssetManager来获取资源文件。为了避免插件和宿主中资源id冲突的问题，加载插件中资源时会创建新的Resources、AssetManage对象，其中AssetManage需要通过反射机制添加插件的资源路径 参考文档插件化-资源加载 123456789AssetManager assetManager = AssetManager.class.newInstance();try &#123; AssetManager.class.getDeclaredMethod("addAssetPath", String.class).invoke( assetManager, apkPath);&#125; catch (Throwable th) &#123; System.out.println("debug:createAssetManager :"+th.getMessage()); th.printStackTrace();&#125;return assetManager; 宿主环境渲染插件中的布局文件 上面已经实现了加载插件中资源和类文件的功能， 获取到插件的布局后通过LayoutInflater来渲染布局。需要注意的是，获取LayoutInflater实例时需要对Context对象进行封装，重写Context 的getResources()、getAssets()、以及getClssLoader()方法，返回对应插件的相关信息。 同时需要重写getSystemService()实例化方法，通过cloneInContext()方法使设置的Context生效 参考 360Replugin项目 相关分析文档 Replugin- 插件的安装和加载原理 以及Replugin项目中的 com.qihoo360.loader2.PluginContext 类文件 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public class PluginWrapper extends ContextWrapper &#123; private Resources mResources; private LayoutInflater mInflater; private ClassLoader mClassLoader; private String TAG=PluginWrapper.class.getSimpleName(); public PluginWrapper(Context base,Resources resources,ClassLoader classLoader) &#123; super(base); this.mResources = resources; this.mClassLoader=classLoader; &#125; @Override public Object getSystemService(String name) &#123; if (LAYOUT_INFLATER_SERVICE.equals(name)) &#123; if (mInflater == null) &#123; LayoutInflater inflater = (LayoutInflater) super.getSystemService(name);// // 新建一个，设置其工厂 mInflater = inflater.cloneInContext(this); &#125; return mInflater; &#125; return super.getSystemService(name); &#125; @Override public AssetManager getAssets() &#123; if (mResources != null) &#123; return mResources.getAssets(); &#125; return super.getAssets(); &#125; @Override public Resources getResources() &#123; if (mResources != null) &#123; return mResources; &#125; return super.getResources(); &#125; /** * 重写getClassLoader()方法， * 布局渲染时加载插件包里面的class文件 * 避免自定义布局 ClassNotFoundException 问题 * @return 插件包的classloader */ @Override public ClassLoader getClassLoader() &#123; if (mClassLoader!=null)&#123; return mClassLoader; &#125; Log.d(TAG,"getClassLoader()"); return super.getClassLoader(); &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[面试总结]]></title>
    <url>%2F2019%2F04%2F24%2F%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JAVA 篇 有事没事刷点题 HashMap 原理分析HashMap实现原理及源码分析 类加载过程JAVA对象的初始化过程 类加载 一个java对象在初始化前会进行类加载，在JVM中生成Class对象 12345如果该类有父类，则先加载父类 1. 初始化类静态成员 2. 执行类静态代码块` 创建对象 如果该类有父类，则创建对象时会先创建其父类的对象，外层包裹子类的属性和方法，然后返回子类的引用 1234如果该类有父类，先创建父类的对象。 1.初始化该类普通成员。 2.执行普通代码块。 3.调用该类构造方法。 String、StringBuffer、StringBuilder的区别 String 是用 final 修饰的类，由于它的不可变性，类似拼接、裁剪字符串等，都会产生新的对象。 StringBuffer 解决上面拼接对象而提供一个类，可以通过 append等方法拼接，是线程安全的，由于线程安全，效率也下降。 StringBuilder 跟StringBuffer 差不多，只是去掉了线程安全，所以优先使用 StringBuilder。 说说String 为什么会产生新的对象？比如 String a = “1” String b = a + “2”，当执行这条指令时，会在常量池中产生一个对象指向a，而创建b时也会重新在常量池中生成b的对象；多次创建容易触发 GC，这也是为什么不建议使用 String 类去拼接的问题。 JAVA回收机制内存泄漏与排查流程 JAVA回收算法 java中是通过GC（Garbage Collection）来进行回收内存，那jvm是如何确定一个对象能否被回收的呢？主要有下面的回收算法 引用计数法 引用计数是垃圾收集器中的早期策略。在这种方法中，堆中每个对象实例都有一个引用计数。当一个对象被创建时，且将该对象实例分配给一个变量，该变量计数设置为1。当任何其它变量被赋值为这个对象的引用时，计数加1（a = b,则b引用的对象实例的计数器+1），当一个对象实例的某个引用超过了生命周期或者被设置为一个新值时，对象实例的引用计数器减1。任何引用计数器为0的对象实例可以被当作垃圾收集。当一个对象实例被垃圾收集时，它引用的任何对象实例的引用计数器减1。 缺点： 无法检测出循环引用。如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。例如下面代码片段中，最后的Object实例已经不在我们的代码可控范围内，但其引用仍为1，此时内存便产生泄漏。 12345Object o1 = new Object() //Object的引用+1，此时计数器为1Object o2;o2.o = o1; //Object的引用+1，此时计数器为2o2 = null;o1 = null; //Object的引用-1，此时计数器为1 可达性分析算法 可达性分析算法是现在java的主流方法，通过一系列的GC ROOT为起始点，从一个GC ROOT开始，寻找对应的引用节点，找到这个节点以后，继续寻找这个节点的引用节点，当所有的引用节点寻找完毕之后，剩余的节点则被认为是没有被引用到的节点，即无用的节点（即图中的ObjD、ObjE、ObjF）。由此可知，即时引用成环也不会导致泄漏。 123456java中可作为GC Root的对象有： 1、方法区中静态属性引用的对象 2、方法区中常量引用的对象 3、本地方法栈JNI中引用的对象（Native对象） 4、虚拟机栈（本地变量表）中正在运行使用的引用 但是，可达性分析算法中不可达的对象，也并非一定要被回收。当GC第一次扫过这些对象的时候，他们处于“死缓”的阶段。要真正执行死刑，至少需要经过两次标记过程。如果对象经过可达性分析之后发现没有与GCRoots相关联的引用链，那他会被第一次标记，并经历一次筛选，这个对象的finalize方法会被执行。如果对象没有覆盖finalize或者已经被执行过了。虚拟机也不会去执行finalize方法。Finalize是对象逃狱的最后一次机会。 强引用、软引用、弱引用、虚引用 引用类型 关键字 特点 强引用 new 通常使用的创建对象的方法，new Object(),只要对象存在就不会被回收 软引用 SoftReference 用来描述一些有用但不是必需的对象，在内存溢出之前，系统会将这类对象GC回收,如果内存还不够，再报出内存溢出异常 弱引用 WeakReference 当系统发生GC前，无论内存是否够用，对象都会被回收 虚引用 PhantomReference 最弱的引用，虚引用不会影响对象的生存时间，只是当对象回收时收到一个系统通知 线程 线程池分类 创建方法 特点 适用场景 FixedThreadPool Executors.newFixedThreadPool(3) 创建固定数量的核心线程，线程空闲时不会被回收，除非线程池被关闭，所有线程都处于活动状态时，新任务会进入等待状态 能够快速响应外界请求 CachedThreadPool Executors.newCachedThreadPool() 创建数量不固定的非核心线程的线程池，如果有空闲线程则复用，否则创建新的线程，每个线程有超时时间60s 适合执行大量不耗时间的任务 ScheduledThreadPool Executors.newScheduledThreadPool(5) 核心线程固定，非核心线程不固定，非核心线程闲置时会被回收 适合执行固定周期的重复任务 SingleThreadExecutor Executors.newSingleThreadExecutor() 只创建一个核心线程 统一所有任务到一个线程中执行，不用考虑线程同步]]></content>
      <tags>
        <tag>面试</tag>
        <tag>总结</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[开发一个Servlet项目]]></title>
    <url>%2F2018%2F05%2F18%2F%E5%BC%80%E5%8F%91%E4%B8%80%E4%B8%AAServlet%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[在开发项目过程中，客户端经常会遇到以下问题：1. 开发环境未能及时部署造成的开发阻塞问题；2. 一些界面依赖后台接口动态绘制UI,需要后台配合修改数据。通常客户端会在本地写一些假数据用来展示界面，等开发环境部署后，在联调接口和优化接口请求逻辑同时得记得把假数据给移除掉。这样的话客户端会多做一些无用功。后台正式开发完之前肯定都是些假数据，但是我们可以把假数据放到服务器上而不是客户端。所以，现在的需求就是：有一个服务可以按照接口协议接收客户端的上传报文并按照上传报文返回相应的返回报文（这里的返回报文其实就是一段按着接口协议的静态文本）。当然，后台小伙伴可没空给我写这个，不过技术上还是给了很多帮助的。 开发环境配置项目开发需要下面工具,这篇博客主要记录IDEA创建Servlet项目，所以工具的下载和环境变量的配置自己百度搜索。 JDK IntelliJ IDEA(需要下载Ultimate版) Tomcat idea 创建Servlet项目 现在后台开发基本都使用IDEA了，而且跟AS是同一家公司的产品，界面风格快捷键操作也很像，对于Android开发者上手还是挺友好的。 新建Java Web项目 创建最简单的Servlet项目，不需要引用Spring、Struts等框架 添加Tomcat依赖 项目创建成功后，需要引入Tomcat的依赖。在Project Structure中进行如下操作 完善项目配置新建Servlet类，处理报文逻辑 添加好Tomcat的依赖后，在工程的’src’目录下创建自己的包名，在包底下新建一个类继承HttpServlet。保证上面引入Tomcat依赖成功，不然找不到HttpServlet类 12345678910111213public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doGet(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; super.doPost(req, resp); &#125;&#125; 修改web.xml 配置文件 在web–&gt;WEB-INF–&gt;web.xml 文件中添加下面信息 12345678&lt;servlet&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.first.FirstServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;FirstServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/firstservlet&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置Tomcat 如上，基本的项目框架已经完善。但是想让项目通过网络访问，还差最后一步，为项目配置Tomcat服务器。 日志显示下面表示服务启动成功 12[2018-05-22 03:18:59,303] Artifact FirstServlet:war exploded: Artifact is deployed successfully[2018-05-22 03:18:59,303] Artifact FirstServlet:war exploded: Deploy took 715 milliseconds 测试服务 Tomcat服务启动成功后就可以通过Postman或者其他工具来测试服务接口 修改’FirstServlet’中的处理逻辑，处理上传报文和返回报文。这里只是做了简单处理：读取打印上传报文，添加自定义信息拼接上传报文最为回复报文返回。实际可按照自己项目中的报文加解密规则处理。 12345678910111213141516171819202122232425262728public class FirstServlet extends HttpServlet &#123; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; doPost(req, resp); &#125; @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; InputStream inputStream = req.getInputStream(); byte[] b = new byte[1024]; int l = 0; ByteArrayOutputStream baos = new ByteArrayOutputStream(); while (((l = inputStream.read(b)) != -1)) &#123; baos.write(b, 0, l); &#125; String request = new String(baos.toByteArray()); System.out.println("上传报文：" + request); resp.setContentType("text/html;charset=UTF-8");//解决返回报文中中文乱码问题 resp.getWriter().println("回复报文开始----------------"); resp.getWriter().println(request); resp.getWriter().println("回复报文结束----------------"); resp.getWriter().close(); &#125;&#125; 访问路径为：本机ip地址+8080（tomcat端口）+/firstservlet(项web.xml中url-pattern字段)]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>servlet</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[getter()模板技巧]]></title>
    <url>%2F2018%2F04%2F08%2Fgetter-%E6%A8%A1%E6%9D%BF%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[通常在处理bean类的时候，我们会通过AS的模板功能添加setter()和getter()方法,这种操作相当方便。但有些时候不能适应我们所有的需求，下面记录下适应具体需求时的一些修改。 定义全局变量时以’m’开头 有人喜欢在定义变量时加个前缀，用来区分全局变量、静态变量、局部变量等，例如常用的成员变量前缀为m。如果添加了前缀，在生成get\set方法时，方法名会带上这个前缀,如下 12345private String mName; public String getmName() &#123; return mName; &#125; 避免方法名携带前缀字段可以尝试用下面的方法 进入AS的Preferences界面，Editor--&gt;Code Style--&gt;Java,在’Name Prefix’中添加前缀字段，例如’m’ 重新生成’get’方法 12345private String mName; public String getName() &#123; return mName; &#125; Getter 模板修改–自动处理 null 判断 开发中会经常遇到实体类的一些属性未初始化造成的空指针异常，尤其是跟后台定义的接口实体类，由于解析或其他问题属性未初始化在调用时直接报空指针异常。实体类中常见的有String类型和List类型，我们可以修改下get方法的模板，在使用属性时做一层非空处理。 参考链接 修改后生成代码如下: 12345678910111213private String mName; private List&lt;String&gt; mList; public String getName() &#123; return mName == null ? "" : mName; &#125; public List&lt;String&gt; getList() &#123; if (mList == null) &#123; return new ArrayList&lt;&gt;(); &#125; return mList; &#125; 修改生成get的模板方法如下 进入生成get方法的弹窗界面，点击右上角进入模板编辑界面 新建代码模板,修改模板代码如下(可以复制原来模板中的内容主要修改了$(name){…}中的return规则) 12345678910111213141516171819202122232425262728#if($field.modifierStatic)static ###end$field.type ###set($name = $StringUtil.capitalizeWithJavaBeanConvention($StringUtil.sanitizeJavaIdentifier($helper.getPropertyName($field, $project))))#if ($field.boolean &amp;&amp; $field.primitive) #if ($StringUtil.startsWithIgnoreCase($name, 'is')) #set($name = $StringUtil.decapitalize($name)) #else is###end#else get###end$&#123;name&#125;() &#123; #if ($field.string) return $field.name == null ? "" : $field.name; #else #if ($field.list) if ($field.name == null) &#123; return new ArrayList&lt;&gt;(); &#125; return $field.name; #else return $field.name; #end #end&#125;]]></content>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[build.gradle的常用配置]]></title>
    <url>%2F2018%2F03%2F26%2Fbuild-gradle%E7%9A%84%E5%B8%B8%E7%94%A8%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[这篇主要记录下build.gradle文件的常用配置，例如修改打包命名和路径、统一管理多moudle的依赖库版本等。根据项目中具体用到的配置，这篇也会持续更新。官方文档 修改apk名称 通过AS工具打包默认命名规则为app-debug.apk或者app-release.apk。实际使用中可能需要命名规则中包含更多信息，例如版本名称、打包时间、渠道信息等。这种效果可以在项目的build.gradle文件中添加配置信息来实现。 1234567891011// 修改打包后app命名开始 def today = new Date().format('MMddHHmm') def name = new String(defaultConfig.applicationId) .substring(defaultConfig.applicationId.lastIndexOf(".")+1) android.applicationVariants.all &#123; variant -&gt; variant.outputs.each &#123; output -&gt; def file = output.outputFile output.outputFile = new File(file.parent, name + "_" + buildType.name + "_V" + defaultConfig.versionName + "_" + today + ".apk") &#125; &#125; // 修改打包后app命名结束 gradle3.0之后需要使用下面方法 12345678910//修改打包命名开始 def today = new Date().format('MMddHHmm') def name = new String(defaultConfig.applicationId) .substring(defaultConfig.applicationId.lastIndexOf(".") + 1) android.applicationVariants.all &#123; variant -&gt; variant.outputs.all &#123; outputFileName = name + "_" + buildType.name + "_V" + defaultConfig.versionName + "_" + today+".apk" &#125; &#125; //修改打包命名结束 属性 column output.outputFile.parent 生成apk的路径，这个是默认路径在项目/app/build/outpus/apk buildType.name 编译类型，就是debug或者release defaultConfig.versionName 在defaultConfig标签下写的版本号 today 定义的打包时间字符串 统一依赖库版本管理 如果项目中存在多个moudle的话，为了避免moudle的依赖库版本不统一导致重复依赖，最好统一配置依赖版本。下面提供两种配置方式。 在顶级build.gradle文件中配置依赖版本信息 在顶级build.gradle文件中添加ext代码块 1234567891011121314151617181920212223242526272829303132333435363738// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; google() jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:3.0.1' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; google() jcenter() &#125;&#125;task clean(type: Delete) &#123; delete rootProject.buildDir&#125;ext &#123; compileSdkVersion = 26 minSdkVersion = 19 targetSdkVersion = 26 versionCode = 1 versionName = '1.0' supportLibraryVersion='26.1.0'&#125; 在各个moudle的build.gradle引用配置信息 123456789101112android &#123; // Use the following syntax to access properties you defined at the project level: // rootProject.ext.property_name compileSdkVersion rootProject.ext.compileSdkVersion buildToolsVersion rootProject.ext.buildToolsVersion ...&#125;...dependencies &#123; compile "com.android.support:appcompat-v7:$&#123;rootProject.ext.supportLibVersion&#125;" ...&#125; 在gradle.properties文件中配置依赖版本信息 在gralde.properties文件中添加依赖版本信息 123456789# When configured, Gradle will run in incubating parallel mode.# This option should only be used with decoupled projects. More details, visit# http://www.gradle.org/docs/current/userguide/multi_project_builds.html#sec:decoupled_projects# org.gradle.parallel=trueTARGET_SDK_VERSION=21COMPILE_SDK_VERSION=25BUILD_TOOL_SVERSION=25.0.2MIN_SDK_VERSION=14SUPPORT_VERSION=25.4.0 在各个moudle的build.gradle引用配置信息 在gradle.properties中配置的信息会作为字符串处理，如果参数需要数值类型的话需要在后面添加as int 12345678910111213android &#123; // Use the following syntax to access properties you defined at the project level: // rootProject.ext.property_name compileSdkVersion COMPILE_SDK_VERSION as int buildToolsVersion BUILD_TOOL_SVERSION ...&#125;...dependencies &#123; compile "com.android.support:appcompat-v7:$&#123;SUPPORT_VERSION&#125;" compile 'com.android.support:design:' + SUPPORT_VERSION ...&#125; 与应用代码共享自定义字段和资源 在构建时，Gradle 将生成 BuildConfig 类，以便应用代码可以检查与当前构建有关的信息。可以使用 buildConfigField() 函数，将自定义字段添加到 Gradle 构建配置文件的 BuildConfig 类中，然后在应用的运行时代码中访问这些值。同样，也可以使用 resValue() 添加应用资源值。官方文档 1234567891011121314151617181920android &#123; buildTypes &#123; release &#123; // These values are defined only for the release build, which // is typically used for full builds and continuous builds. buildConfigField("String", "BUILD_TIME", "\"$&#123;minutesSinceEpoch&#125;\"")//在BuildConfild类中生成BUILD_TIME字段 resValue("string", "build_time", "$&#123;minutesSinceEpoch&#125;") // 在资源文件中生成build_time 字符串，目录为app/build/generated/res/resValues/[flavor-name]/[buildType]/values/generated.xml ... &#125; debug &#123; // Use static values for incremental builds to ensure that // resource files and BuildConfig aren't rebuilt with each run. // If they were dynamic, they would prevent certain benefits of // Instant Run as well as Gradle UP-TO-DATE checks. buildConfigField("String", "BUILD_TIME", "\"0\"") resValue("string", "build_time", "0") &#125; &#125;&#125; 在应用代码中使用 12Log.i(TAG, BuildConfig.BUILD_TIME);Log.i(TAG, getString(R.string.build_time));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>gradle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RoundImageView]]></title>
    <url>%2F2018%2F03%2F14%2FRoundImageView%2F</url>
    <content type="text"><![CDATA[在项目中我们会经常用到圆形图片的情况，但是谷歌官方并没有提供这种视图控件，通常我们使用自定义视图来实现。这个CircleImageView是我们以前项目中用到的一个实现圆形图片的控件。最近有时间所以研究了一下源码，圆形图片主要是通过BitmapShader来实现，代码也比较容易理解对刚开始研究自定义视图的同学还是很有帮助的。另外我也简单修改了源码实现圆角图片和圆形图片的功能。 定义视图属性 明确自定义视图要实现的功能，并为其功能定义配置的属性信息。这里我想实现的是带有边框的圆角或者圆形的视图，并且边框的宽度、颜色、是否覆盖图片，圆角图片的圆角半径等功能都可动态配置。所以定义视图属性主要如下： 1234567891011&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;resources&gt; &lt;declare-styleable name="RoundImageView"&gt; &lt;attr name="round_border_width" format="dimension" /&gt;&lt;!--边框宽度--&gt; &lt;attr name="round_border_color" format="color" /&gt;&lt;!--边框颜色--&gt; &lt;attr name="round_border_overlay" format="boolean" /&gt;&lt;!--边框是否覆盖图片--&gt; &lt;attr name="round_background_color" format="color" /&gt;&lt;!--背景颜色--&gt; &lt;attr name="round_oval" format="boolean" /&gt;&lt;!--圆形/圆角矩形--&gt; &lt;attr name="round_corner_radius" format="dimension" /&gt;&lt;!--圆角半径--&gt; &lt;/declare-styleable&gt;&lt;/resources&gt; 自定义RoundImageView继承系统ImageView画笔的初始化 整个视图我们可以理解为有三部分：背景、图片、边框。每一部分是独立绘制的，这里需要初始化三种类型的画笔。 12345678910111213mBitmapShader = new BitmapShader(mBitmap, Shader.TileMode.CLAMP, Shader.TileMode.CLAMP); //图片画笔 mBitmapPaint.setAntiAlias(true); mBitmapPaint.setShader(mBitmapShader); //边框画笔 mBorderPaint.setStyle(Paint.Style.STROKE); mBorderPaint.setAntiAlias(true); mBorderPaint.setColor(mBorderColor); mBorderPaint.setStrokeWidth(mBorderWidth); //背景画笔 mCircleBackgroundPaint.setStyle(Paint.Style.FILL); mCircleBackgroundPaint.setAntiAlias(true); mCircleBackgroundPaint.setColor(mCircleBackgroundColor); 上面图片画笔设置了BitmapShader为着色器。所谓着色器我是这样理解的，例如上面边框画笔设置了一个颜色值，画笔在视图画布上绘制的时候会让每个像素都绘制成相应颜色，直到绘制完整个视图。如果像图片画笔那样设置了BitmapShader为着色器，画笔在绘制的时候会让着色器携带的图片绘制在视图上。如果图片大小不足以占满整个视图，画笔会根据Shader.TileMode来充满整个视图。CLAMP用边缘色彩填充多余空间、MIRROR重复使用镜像模式的图像来填充多余空间 、REPEAT重复原图像来填充多余空间。 视图区域的计算 视图绘制区域的计算逻辑也比较好理解，主要做了兼容视图的padding属性的处理。另外，如果是圆形视图，绘制区域会以较短的边作为半径，既绘制区域内最大内切圆。 1234567891011121314151617181920212223/** * 计算可绘制的区域 * * @return */ private RectF calculateBounds() &#123; int availableWidth = getWidth() - getPaddingLeft() - getPaddingRight(); int availableHeight = getHeight() - getPaddingTop() - getPaddingBottom(); if (mIsOval) &#123; int sideLength = Math.min(availableWidth, availableHeight); /** * 如果是圆形图片，则选取较短的边作为直径，较长的一边位置居中 */ float left = getPaddingLeft() + (availableWidth - sideLength) / 2f; float top = getPaddingTop() + (availableHeight - sideLength) / 2f; return new RectF(left, top, left + sideLength, top + sideLength); &#125; else &#123; return new RectF(getPaddingLeft(), getPaddingTop(), getPaddingLeft() + availableWidth, getPaddingTop() + availableHeight); &#125; &#125; 上面计算的是视图内可绘制的最大区域，边框，图片、背景都应该在这个区域内绘制。不过属性中定义了round_border_overlay边框是否覆盖图片这个配置属性，所以当边框不是覆盖在图片上时，图片的可绘制区域应减少边框的宽度大小。 12345678910mBorderRect.set(calculateBounds()); mDrawableRect.set(mBorderRect); if (!mBorderOverlay &amp;&amp; mBorderWidth &gt; 0) &#123; /** * 当绘制圆角矩形时，圆角四周和border边框会有留白,所以适当增加图片的绘制区域 */ mDrawableRect.inset(mBorderWidth - 1f, mBorderWidth - 1f); &#125; 图片的缩放处理 图片的可绘制区域确定后为了更好的显示效果，需要根据图片绘制区域和图片的大小进行缩放处理。 123456789101112131415161718192021222324 private void updateShaderMatrix() &#123; float scale; float dx = 0; float dy = 0; mShaderMatrix.set(null);/** * * 缩放值按照Math.max(Vw/Bw,Vh/Bh)，即图片的宽或高比上视图的宽或高最大值来计算，较小的一边通过计算偏移量居中。 * 保证缩放后的图片占满视图。 */ if (mBitmapWidth * mDrawableRect.height() &gt; mDrawableRect.width() * mBitmapHeight) &#123; scale = mDrawableRect.height() / (float) mBitmapHeight; dx = (mDrawableRect.width() - mBitmapWidth * scale) * 0.5f; &#125; else &#123; scale = mDrawableRect.width() / (float) mBitmapWidth; dy = (mDrawableRect.height() - mBitmapHeight * scale) * 0.5f; &#125; mShaderMatrix.setScale(scale, scale); mShaderMatrix.postTranslate((int) (dx + 0.5f) + mDrawableRect.left, (int) (dy + 0.5f) + mDrawableRect.top); mBitmapShader.setLocalMatrix(mShaderMatrix); &#125; CircleImageView的源码中是通过 mBitmapWidth * mDrawableRect.height() &gt; mDrawableRect.width() * mBitmapHeight判断来计算缩放比的，刚开始一直没明白这种算法。后来又参考了网上其他图片缩放的一些算法明白了它的计算方式。为了保证缩放后的图片能能够占满整个视图，缩放值scale=Math.max(视图高/图片高，视图宽/图片宽)，这个算法的变形就是上面的形式。 视图绘制 画笔、绘制区域、图片缩放等逻辑都处理好后，接下来就是视图的绘制。重写onDraw()方法。根据圆角或者圆形调用canvas.drawRoundRect或者canvas.drawCircle方法绘制视图。绘制边框是需要注意，画笔设置了setStrokeWidth属性，绘制区域为绘制区域中心到strokWidth中心的距离，所以绘制边框时需要将绘制区域向内缩小strokeWidth/2的大小，保证边框完全显示。 123456789101112131415161718192021222324 if (mIsOval) &#123; // 绘制圆形 if (mCircleBackgroundColor != Color.TRANSPARENT) &#123; canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(), mDrawableRect.width() / 2f, mCircleBackgroundPaint); &#125; canvas.drawCircle(mDrawableRect.centerX(), mDrawableRect.centerY(), mDrawableRect.width() / 2f, mBitmapPaint); if (mBorderWidth &gt; 0) &#123;// 绘制圆形的半径等于圆心到画笔宽度中心的距离 canvas.drawCircle(mBorderRect.centerX(), mBorderRect.centerY(), mBorderRect.width() / 2f - mBorderWidth / 2f, mBorderPaint); &#125; &#125; else &#123; // 绘制圆角矩形 if (mCircleBackgroundColor != Color.TRANSPARENT) &#123; canvas.drawRoundRect(mDrawableRect, mRadius, mRadius, mCircleBackgroundPaint); &#125; canvas.drawRoundRect(mDrawableRect, mRadius, mRadius, mBitmapPaint); if (mBorderWidth &gt; 0) &#123; RectF rectF = new RectF(mBorderRect); // 绘制圆角矩形的宽/高等于矩形中心到上/下画笔宽度中心的距离 rectF.inset(mBorderWidth / 2f, mBorderWidth / 2f); canvas.drawRoundRect(rectF, mRadius, mRadius, mBorderPaint); &#125; &#125; 效果预览源码地址]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[布局优化]]></title>
    <url>%2F2018%2F01%2F02%2F%E5%B8%83%E5%B1%80%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[布局优化，主要了解include、merge、ViewSub标签的作用 include 标签 include 标签主要用来布局的复用，当然如果当前界面的布局太复杂，为了布局代码的整洁，也可以将部分模块的抽出为单独布局，再通过include标签引入。官方文档 include 标签的使用也比较简单。新建复用布局titlebar_layout，在目标布局中引入位置添加&lt;include layout=&quot;@layout/titlebar_layout&quot;/&gt;即可。需要注意的是include标签只支持layout_ 开头的属性例如layout_margin等。使layout_属性生效的前提是添加了layout_width、layout_height属性如下： 123456&lt;include layout="@layout/titlebar_layout" android:layout_width="match_parent" android:layout_height="wrap_content" android:layout_margin="10dp" /&gt; 另外，在复用的布局中使用tools:showIn=&quot;@layout/目标布局可以在复用布局中看到整体的预览 merge 标签 merge 标签的作用是用来减少视图层级中多余的一层ViewGroup容器。官方文档 merge通常和include标签搭配使用，如果复用布局中的根布局和目标布局中引入include标签的父布局相同的话，复用布局的根标签可以改成merge，从而减少一层ViewGroup的嵌套。 merge在自定义布局中的应用 这里的自定义布局并不是通常的重写onMearuse()、onLayout()、onDraw()。上面提到，merge标签用来减少多余一层ViewGroup容器的复用，这里可以将布局文件的根标签抽取出来，以自定义View继承的方式实现，同时布局文件中的根布局标签改为merge 例如现在想要将下面的布局自定义为一个View 1234567891011121314&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" android:layout_width="match_parent" android:layout_height="wrap_content"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;/RelativeLayout&gt; 1.将布局文件的根部局以自定义View的形式抽出 自定义View 最好提供多种构造器满足不同形式的需求 123456789101112131415161718public class TabItemView extends RelativeLayout&#123;// 直接实例化对象 public TabItemView(Context context) &#123; this(context,null); &#125;// 通过布局文件实例化对象 public TabItemView(Context context, @Nullable AttributeSet attrs) &#123; super(context, attrs); setLayoutParams(new RelativeLayout.LayoutParams(LayoutParams.WRAP_CONTENT,LayoutParams.WRAP_CONTENT)); // 布局文件中根部局为merge标签，所以第三个参数应为this,当前继承的ViewGroup 为视图的根部局 inflate(context, R.layout.tabitem,this); initView(); &#125; private void initView() &#123; &#125;&#125; 2.修改原来布局根标签为merge 减少布局的嵌套 123456789101112&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;merge xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt; &lt;TextView android:layout_width="wrap_content" android:layout_height="wrap_content" /&gt;&lt;/merge&gt; 3.引用自定义布局 123456 //在布局文件的引用 &lt;包名.tab.TabItemView android:layout_width="wrap_content" android:layout_height="wrap_content"/&gt;//在代码中的引用TabItemView itemView=new TabItemView(getBaseContext(); PS.因为布局文件中根标签为merge,在inflate(context, R.layout.tabitem,this)第三个参数需要为this,依赖当前布局为父布局 ViewSub 标签 ViewSub 是一个轻量级的View,没有尺寸，只有setVisibility(VISIBLE)或者inflate()方法调用时才会绘制对应的布局。所以ViewSub适合界面中不是每次都会绘制的一些布局。例如列表界面中的空数据界面。官方文档 在布局文件中声明ViewSub标签123456&lt;ViewStub android:id="@+id/stub_empty" android:layout_width="match_parent" android:layout_height="match_parent" android:inflatedId="@+id/inflate_empry" android:layout="@layout/widget_empty_layout" /&gt; 在代码中按需加载ViewSub 当ViewSub调用setVisibility(VISIBLE)或者inflate()方法前，通过android:inflatedId=&quot;@+id/inflate_empry&quot; 拿到的视图为空；调用之后ViewSub将会被它对应的布局所替代可以通过android:id=&quot;@+id/stub_empty&quot;拿到对应的布局内容。12345if (emptyView == null) &#123; emptyStub = (ViewStub) findViewById(R.id.stub_empty); emptyStub.inflate(); emptyView = findViewById(R.id.inflate_empry); &#125; PS: inflate() 方法只能被调用一次，如果再次调用会报异常信息 ViewStub must have a non-null ViewGroup viewParent。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity启动模式]]></title>
    <url>%2F2017%2F11%2F15%2FActivity%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[Activity启动模式 清单文件中配置启动模式launchMode官方文档 singleTask 设置A Activity的启动模式为singleTask,启动顺序为A--&gt;B--&gt;C--&gt;A各Activity的生命周期如下: 按照启动顺序，各个界面依次调用onCreate()方法。当从C启动到A时，B界面走了onDestory()方法，A界面不会重新创建，走了onNewIntent()方法，随后C界面销毁走onDestory()方法 当Activity的启动模式设置为singleTask时，任务栈中只会创建一次这个Activity的对象，当重复启动该Activity时会调用onNewIntent()方法，而不是onCreate()方法，同时会将任务栈中该Activity上面的Activity清除出栈。 123456D/whl: AActivity------onCreateD/whl: BActivity------onCreateD/whl: CActivity------onCreateD/whl: BActivity------onDestroyD/whl: AActivity------onNewIntentD/whl: CActivity------onDestroy singleTop 设置B Activity的启动模式为singleTop,启动顺序为A--&gt;B--&gt;B各Activity的生命周期如下: 从A启动到B，这时BActivity位于栈顶，再次跳转BActivity时，界面不会重新创建，走onNewIntent()方法 当Activity的启动模式设置为singleTop时，任务栈中允许创建多个该Activity的对象。但是，如果当该Activity位于任务栈顶时再次启动该界面，不会创建新的对象。 123D/whl: AActivity------onCreateD/whl: BActivity------onCreateD/whl: BActivity------onNewIntent Intent中配置FLAG 关于Activity的启动模式除了在清单中静态配置launchMode之外，也可以在代码中通过设置Intent的FLAG动态设置。官方文档 FLAG_ACTIVITY_SINGLE_TOP 作用同launchMode设置singleTop FLAG_ACTIVITY_CLEAR_TOP If set, and the activity being launched is already running in the current task, then instead of launching a new instance of that activity, all of the other activities on top of it will be closed and this Intent will be delivered to the (now on top) old activity as a new Intent. 按照官方文档的解释，当设置这个FLAG通过Intent启动目标Activity时，在栈中位于目标Activity之上的界面都会被清除出栈。目标Activity会位于栈顶，接受新的Intent。根据文档，我的理解是目标Activity的onNewIntent()方法会被调用，且不会创建新的对象。通过Demo来验证一下A--&gt;B--&gt;C--&gt;B。依次启动A、B、C界面，当C启动B时，设置FLAG_ACTIVITY_CLEAR_TOPFLAG。 123456AActivity------onCreateBActivity------onCreateCActivity------onCreateBActivity------onDestroyBActivity------onCreateCActivity------onDestroy 运行结果好像和文档描述不太一样，结论是设置FLAG_ACTIVITY_CLEAR_TOPFLAG启动目标Activity，会将栈中位于目标Activity上面的Activity清理出栈，和launchMode设置singleTask不同，这个FLAG同时导致目标Activity也会销毁然后重建 Ps. 如果想要清除目标Activity上面的Activity，同时目标Activity不会重建可以设置FLAGintent.setFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP|Intent.FLAG_ACTIVITY_SINGLE_TOP) FLAG_ACTIVITY_CLEAR_TASK If set in an Intent passed to Context.startActivity(), this flag will cause any existing task that would be associated with the activity to be cleared before the activity is started. That is, the activity becomes the new root of an otherwise empty task, and any old activities are finished. This can only be used in conjunction with FLAG_ACTIVITY_NEW_TASK. 设置这个FLAG会清空Activity栈，但是使用会有问题，它需要搭配另外一个FLAG联合使用intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK)A–&gt;B–&gt;C 依次启动A、B、C当重B启动C时添加FLAG 12345AActivity------onCreateBActivity------onCreateAActivity------onDestroyCActivity------onCreateBActivity------onDestroy 当设置Intent.FLAG_ACTIVITY_NEW_TASK|Intent.FLAG_ACTIVITY_CLEAR_TASK时，会清空当前任务栈，目标Activity重新创建，且位于新栈的最底部 FLAG_ACTIVITY_REORDER_TO_FRONT If set in an Intent passed to Context.startActivity(), this flag will cause the launched activity to be brought to the front of its task’s history stack if it is already running.这个FLAG理解比较简单A–&gt;B–&gt;C–&gt;B 依次启动A、B、C，栈中的顺序为ABC,当从C启动B时设置FLAG_ACTIVITY_REORDER_TO_FRONT日志如下： 1234AActivity------onCreateBActivity------onCreateCActivity------onCreateBActivity------onNewIntent B界面会重新回到栈顶，C界面也没有出栈，栈中顺序改为了A–&gt;C–&gt;B。但是使用中存在一个问题，通过设置这个标签启动B到栈顶，如果按返回键日志显示B出栈A和C并没有出栈但是程序会退回到桌面，重新进入程序栈中顺序为A–&gt;C 目前就研究了这几个，有兴趣再研究其他的吧]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单聊聊Android程序的运行内存]]></title>
    <url>%2F2017%2F10%2F09%2F%E7%AE%80%E5%8D%95%E8%81%8A%E8%81%8AAndroid%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%BF%90%E8%A1%8C%E5%86%85%E5%AD%98%2F</url>
    <content type="text"><![CDATA[每台手机允许程序的最大内存都不尽相同，如果你的设备已经root，可以查看系统文件获取；当然开发者也可以通过代码获取。 在获取了root权限的设备上查看/system/build.prop 文件，下面是小米5的文件内容12dalvik.vm.heapsize=512m dalvik.vm.heapgrowthlimit=256m 其中heapgrowthlimit 是普通应用的内存限制，当在清单文件中设置了largeHeap=true之后，可以使用的最大内存值 通过代码获取最大运行内存 可以试着修改清单文件中largeHeap的配置，看下每次的打印值。 1long maxMemory=Runtime.getRuntime().maxMemory()/1024/1024; 当然一般程序还是不建议设置largeHeap=true，我们更需要做的是内存的高效管理]]></content>
      <tags>
        <tag>Android扩展</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS2.3后找不到SDKManager启动按钮解决方法]]></title>
    <url>%2F2017%2F10%2F09%2FAS2-3%E5%90%8E%E6%89%BE%E4%B8%8D%E5%88%B0SDKManager%E5%90%AF%E5%8A%A8%E6%8C%89%E9%92%AE%E8%A7%A3%E5%86%B3%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[以前总是习惯通过Preference–&gt; Android SDK下面的Launch Standalone SDK Manage按键启动SDK Manager 图形化界面。但是，最近更新了AS2.3.2后找不到启动按键了，这多少有点儿不适应，于是上网查找通过下面的方式启动SDK Manager。]]></content>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器配置Tomcat]]></title>
    <url>%2F2017%2F09%2F05%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AETomcat%2F</url>
    <content type="text"><![CDATA[在Apache Tomcat官网上选择适当的Tomcat版本，参考云服务器配置JDK将Tomcat的安装包上传到服务器，并解压到相应目录(可以自定义)，这里我将Tomcat的包解压到了/usr/local/tomcat/tomcat8/目录下 1. 解压好即可直接启动12341. 启动命令/usr/local/tomcat/tomcat8/bin/startup.sh2. 关闭命令/usr/local/tomcat/tomcat8/bin/shutdown.sh Tomcat默认端口号是8080，如果服务器没没有开放该端口，需要使用下面方法开放端口 1firewall-cmd --zone=public --add-port=8080/tcp --permanent 出现success表示添加成功然后更新防火墙 1firewall-cmd --reload 重启防火墙 1systemctl restart firewalld.service 测试Tomcat服务是否成功，浏览器输入 1http://[云服务器外网ip]:8080 2. 配置启动脚本 每次通过命令的全路径来启动/关闭服务也很麻烦，那么可以通过一个脚本来实现命令启动Tomcat 创建脚本执行下面代码进入脚本编辑 1vi etc/init.d/tomcat 按i进入编辑模式，拷贝下面内容，按esc键退出编辑，输入:wq保存并退出vim 1234567891011121314151617181920212223242526272829# !/bin/bash # Description: start or stop the tomcat # Usage: tomcat [start|stop|restart] # export PATH=$PATH:$HOME/bin export BASH_ENV=$HOME/.bashrc export USERNAME=&quot;root&quot; case &quot;$1&quot; in start) #startup the tomcat cd [tomcat安装目录]/bin ./startup.sh ;; stop) # stop tomcat cd [tomcat安装目录]/bin./shutdown.sh echo &quot;Tomcat Stoped&quot; ;; restart) $0 stop $0 start ;; *) echo &quot;tomcat: usage: tomcat [start|stop|restart]&quot; exit 1 esac exit 0 为脚本添加执行权限 1chmod +x /etc/init.d/tomcat 创建软连接 12cd usr/binln -s /etc/init.d/tomcat 配置完成后测试是否有效，输入下面命令看Tomcat启动日志 123tomcat starttomcat stoptomcat restart 3.修改默认端口号切换目录到[tomcat根目录]/conf,编辑server.xml修改port端口,然后重启tomcat。 123&lt;Connector port=&quot;8080&quot; protocol=&quot;HTTP/1.1&quot; connectionTimeout=&quot;20000&quot; redirectPort=&quot;8443&quot; /&gt;]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[云服务器配置JDK]]></title>
    <url>%2F2017%2F09%2F03%2F%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AEJDK%2F</url>
    <content type="text"><![CDATA[最近看到了郭神在公众号里的京东云服务器优惠的推送，所以先买了两个月的体验版折腾一下。下面记录下在云服务器下配置JDK环境和Tomcat服务的过程。 1. 上传JDK的包到云服务器 在云服务器上配置JDK首先需要在Oracle上找到适合云服务器系统的JDK版本。连接云服务器，切换或新建目录到JDK的安装目录安装目录可以自定义。下面以两种形式将JDK的包上传到云服务器。 1.1 通过 wget命令 wget命令用来从指定的URL下载文件。wget非常稳定，它在带宽很窄的情况下和不稳定网络中有很强的适应性，如果是由于网络的原因下载失败，wget会不断的尝试，直到整个文件下载完毕。如果是服务器打断下载过程，它会再次联到服务器上从停止的地方继续下载。这对从那些限定了链接时间的服务器上下载大文件非常有用。来自: http://man.linuxde.net/wget1wget http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz 一般下载文件wget命令+下载URl就行了，但是我在下载JDK的时候不能正常下载。上网查询后得配置一些参数，命令如下。 1wget --no-check-certificate --no-cookies --header &quot;Cookie: oraclelicense=accept-securebackup-cookie&quot; http://download.oracle.com/otn-pub/java/jdk/8u144-b01/090f390dda5b47b9b721c7dfaa008135/jdk-8u144-linux-x64.tar.gz 1.2 从本地上传安装包到云服务器 如果使用wget下载速度太慢，或者本地已经有了JDK的安装包，可以通过文件上传的方式将安装包上传到云服务器。这边我已mac为例上传问题。 打开终端选择新建远程连接 选择安全文件传输，输入服务器的IP 输入主机名开始连接 输入密码提示连接成功后开始上传文件 1put 本地文件路径 远程主机路径 2.解压JDK安装包 把JDK的压缩包上传到服务器后，现在使用tar命令解压安装包1tar zxvf [解压文件] 3.配置JDK环境变量 在电脑上为了方便使用JDK的命令我们一般都会配置环境变量。服务器上也是需要配置的。vi命令是UNIX操作系统和类UNIX操作系统中最通用的全屏幕纯文本编辑器。修改vi /etc/profile文件，在最后添加JDK的配置路径。 123#set jdk environment export JAVA_HOME=/usr/lib/jvm/jdk1.7.0_21 （此处根据你所安装jdk的路径实际来写）export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATH 4.查看JDK是否配置成功 到这里JDK的配置基本就完毕了，现在就是需要测试下配置又没有成功了 使环境变量配置生效1source /etc/profile 检验JDK配置是否成功 1java -version 正常显示JDK版本信息则配置成功123java version &quot;1.8.0_144&quot;Java(TM) SE Runtime Environment (build 1.8.0_144-b01)Java HotSpot(TM) 64-Bit Server VM (build 25.144-b01, mixed mode)]]></content>
      <categories>
        <category>Server</category>
      </categories>
      <tags>
        <tag>Server</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebView使用总结]]></title>
    <url>%2F2017%2F06%2F14%2FWebView%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[WebView 实际上继承AbsoluteLayout,但是完全不支持ViewGroup的各种操作；无法查找里面的控件，也不能addView() WebView内部的内容不是控件，而是屏幕绘制出来的内容，底层是一个浏览器引擎：webKit画出来的 webKit:一套开源的，支持多平台的浏览器引擎，几乎所有的android手机官方，默认浏览器，都使用了webkit ，能够将网页用图像的形式绘制出来，同时支持JavaScript和Html5的各种规范。 1. WebView 加载方式1.1 webView.loadUrl(String url)1234// 加载网络链接webView.loadUrl("https://www.baidu.com/")// 加载本地资源(test.html放在assets文件夹下)webView.loadUrl("file:///android_asset/test.html") 1.2 webView.loadData(String data, String mimeType, String encoding)用来加载html代码段，可能会出现页面编码问题，设置编码格式text/html;charset=UTF-8 1234String summary = "&lt;html&gt;&lt;body&gt;You scored &lt;b&gt;192&lt;/b&gt; points.&lt;/body&gt;&lt;/html&gt;"; webview.loadData(summary, "text/html", null); // 标签中包含中文会出现编码问题，设置编码格式 webView.loadData(summary, "text/html;charset=UTF-8", null); 1.3 webView.loadDataWithBaseURL(String baseUrl, String data,String mimeType, String encoding, String historyUrl)和loadData()方法相似都是加载html代码段，但是多了baseUrl,和historyUrl，因为html中css和图片等资源大都使用相对路径，定义了baseUrl可以成功加载这些资源。 1webView.loadDataWithBaseURL(testUrl, IOUtil.readFile(path), "html/text", null, testUrl); 2.WebSettings 下面的设置满足大多数情况下的WebView设置，注意的是’webSettings.setJavaScriptEnabled(true)’需要设置为true,除非界面是完全的静态界面不包含js代码，不然客户端加载网页会失败。 1234567891011121314151617 WebSettings webSettings = webView.getSettings(); webSettings.setCacheMode(WebSettings.LOAD_NO_CACHE);//缓存模式，不加载缓存 webSettings.setJavaScriptEnabled(true);// 网页支持JS脚本 webView.getSettings().setDomStorageEnabled(true);// 开启DOM storage API 功能 //允许混合内容 解决部分(5.0以上)手机 加载不出https请求里面的http的图片 if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; webSettings.setMixedContentMode(WebSettings.MIXED_CONTENT_ALWAYS_ALLOW); &#125; //设置自适应屏幕，两者合用 webSettings.setUseWideViewPort(true); //将图片调整到适合webview的大小 webSettings.setLoadWithOverviewMode(true); // 缩放至屏幕的大小//// //缩放操作 webSettings.setSupportZoom(true); //支持缩放，默认为true。是下面那个的前提。 webSettings.setBuiltInZoomControls(true); //设置内置的缩放控件。若为false，则该WebView不可缩放 webSettings.setDisplayZoomControls(false); //隐藏原生的缩放控件 3. Java和JS的交互 设置WebView支持JS功能 settings.setJavaScriptEnabled(true);在Html中定义需要调用的方法 1234567891011script type="text/javascript"&gt;&lt;!-- JS 调用 Java--&gt; function showToastMessage() &#123; window.android.showToastMessage(text) &#125; &lt;!--Java 调用 JS--&gt; function alertMessage(message)&#123; alert(message) &#125;var text="js 调用 Java";&lt;/script&gt; 3.1 Java调用JS代码3.1.1. 通过WebView的loadUrl()方式12345678910// 必须另开线程进行JS方法调用(否则无法调用) mWebView.post(new Runnable() &#123; @Override public void run() &#123; // 注意调用的JS方法名要对应上 // 调用javascript的callJS()方法 webView.loadUrl("javascript:alertMessage(\"Java 调用 JS \")"); &#125; &#125;); 3.1.2. 通过WebView的evaluateJavascript()方式 该方法的执行不会使页面刷新，而第一种方法（loadUrl ）的执行则会 Android 4.4 后才可使用 123456mWebView.evaluateJavascript（&quot;javascript:callJS(\&quot;Java 调用 JS \&quot;)&quot;, new ValueCallback&lt;String&gt;() &#123; @Override public void onReceiveValue(String value) &#123; //此处为 js 返回的结果 &#125; &#125;); 3.2 JS调用Java代码 定义JS和Java的接口类, 需要在方法上面添加@JavascriptInterface注释 123456789101112//js和java的接口定义 public class JsInteration &#123; @JavascriptInterface public void showToastMessage(final String message) &#123; jsHandler.post(new Runnable() &#123; @Override public void run() &#123; Toast.makeText(MainActivity.this, message, Toast.LENGTH_SHORT).show(); &#125; &#125;); &#125; &#125; 添加JS交互接口,下面’android’为定义的接口名称，字段可以自定义 1webView.addJavascriptInterface(new JsInteration(), "android"); JS的调用方法,语法为window.接口名.方法名(参数)，接口名为上面定义的字段’android’。方法调用如下。 123function showToastMessage() &#123; window.android.showToastMessage(text) &#125; 4.WebChromeClient的常用设置 WebChromeClient是辅助WebView处理Javascript的对话框，网站图标，网站title，加载进度等. 监听网页加载进图，更新进度条12345678910WebChromeClient chromeClient = new WebChromeClient() &#123; @Override public void onProgressChanged(WebView view, int newProgress) &#123; super.onProgressChanged(view, newProgress); progressBar.setProgress(newProgress); &#125; &#125;;webView.setWebChromeClient(chromeClient); 5.WebViewClient的常用设置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859WebViewClient client = new WebViewClient() &#123; @Override public void onPageStarted(WebView view, String url, Bitmap favicon) &#123; super.onPageStarted(view, url, favicon); progressBar.setVisibility(View.VISIBLE); Log.d(TAG, "onPageStarted"); if (mListener != null) &#123; mListener.onPageStart(url); &#125; &#125; @Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123; handler.proceed(); // 加载https自签名网站错误处理 例如https://www.12306.cn/mormhweb/ &#125; @Override public void onPageFinished(WebView view, String url) &#123; super.onPageFinished(view, url); Log.d(TAG, "onPageFinished"); progressBar.setVisibility(View.GONE); if (mListener != null) &#123; mListener.onPageFinish(url); &#125; &#125; @Override public void onReceivedError(WebView view, WebResourceRequest request, WebResourceError error) &#123; super.onReceivedError(view, request, error); Log.d(TAG, "onReceivedError"); if (mListener != null) &#123; mListener.onPageError(); &#125; &#125; @Override public boolean shouldOverrideUrlLoading(WebView webView, String s) &#123; // 有些网页有拨打电话，打开第三方应用等的一些功能，如果有这种需求需要拦截请求地址，如果不是http 、或者https协议，将请求交给系统处理。 Log.d(TAG, "OverrideUrl: " + URLDecoder.decode(s)); if (s.startsWith("http://") || s.startsWith("https://")) &#123; webView.loadUrl(s); &#125; else &#123; try &#123; Uri uri = Uri.parse(s); Intent intent = new Intent(Intent.ACTION_VIEW, uri); getContext().startActivity(intent); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; return true; &#125; &#125;; 6.清除界面1234567private void clearWebView() &#123; if (webView != null) &#123; webView.loadUrl("about:blank"); webView.removeAllViews(); webView.destroy(); &#125; &#125; 7.其他设置7.1拦截下载链接1234567webView.setDownloadListener(new DownloadListener() &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; // TODO 拦截下载请求 &#125; &#125;); WebView 的缓存问题数据缓存 数据缓存分为AppCache和DOM Storage两种 AppCache 我们能够有选择的缓冲web浏览器中所有的东西，从页面、图片到脚本、css等等。尤其在涉及到应用于网站的多个页面上的CSS和JavaScript文件的时候非常有用。其大小目前通常是5M。在Android上需要手动开启（setAppCacheEnabled），并设置路径（setAppCachePath）和容量（setAppCacheMaxSize），而Android中使用ApplicationCache.db来保存AppCache数据！ 1234webView.getSettings().setAppCacheMaxSize(1024*1024*8); String appCachePath = getContext().getApplicationContext().getCacheDir().getAbsolutePath(); webView.getSettings().setAppCachePath(appCachePath); webView.getSettings().setAppCacheEnabled(true); DOM Storage 存储一些简单的用key/value对即可解决的数据，根据作用范围的不同，有SessionStorage和Local Storage两种，分别用于会话级别的存储（页面关闭即消失）和本地化存储（除非主动删除，否则数据永远不会过期）在Android中可以手动开启DOM Storage（setDomStorageEnabled），设置存储路径（setDatabasePath）Android中Webkit会为DOMStorage产生两个文件（my_path/localstorage/http_blog.csdn.net_0.localstorage和my_path/Databases.db) 12// 开启DOM storage API 功能 webView.getSettings().setDomStorageEnabled(true); 常见问题加载带有js脚本的网页失败webSettings.setJavaScriptEnabled(true);设置WebView支持JS,如果不开启的话一些包含JS的网页可能会打开失败，例如百度、简书。另外网页中的JS方法也会不响应。 下载链接点击无反应 需要自己实现DownLoadListener 12345678webView.setDownloadListener(new DownloadListener() &#123; @Override public void onDownloadStart(String url, String userAgent, String contentDisposition, String mimetype, long contentLength) &#123; Uri uri = Uri.parse(url); Intent intent = new Intent(Intent.ACTION_VIEW, uri); startActivity(intent); &#125; &#125;); 加载https网站失败 WebView加载自签名的https链接失败需要在WebViewClient中重写下面方法 1234@Override public void onReceivedSslError(WebView view, SslErrorHandler handler, SslError error) &#123; handler.proceed(); // 加载https的不安全网站处理 例如https://www.12306.cn/mormhweb/ &#125; 使用了Local Storage存储的网页加载失败 如果网页使用了Local Storage存储，如果设置中没给与相应权限，界面会加载空白 12// 开启DOM storage API 功能 webView.getSettings().setDomStorageEnabled(true);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android渠道打包]]></title>
    <url>%2F2017%2F04%2F27%2FAndroid%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%2F</url>
    <content type="text"><![CDATA[今天运营同学要帮忙打渠道包做首发推广，渠道平台要求首发得按要求替换应用图标和闪屏界面。本来做好了挨个打包的准备，后来找到种渠道包替换资源的方法。AS真心强大啊。 1. 添加渠道信息1.1 在app/build.gradle文件中添加渠道信息 如果清单文件中配置了统计渠道字段，替换相应平台的渠道号 123&lt;meta-data android:name="CHANEL" android:value="$&#123;CHANEL&#125;" /&gt; 12345678productFlavors &#123; baidu &#123; manifestPlaceholders=[CHANEL:"baidu"] &#125; yingyongbao &#123; manifestPlaceholders=[CHANEL:"yingyongbao"] &#125; &#125; 2. 替换渠道资源文件在app/src目录下创建渠道包名，例如创建baidu,该目录和main目录同级。在目录下创建main中对应的资源文件，在打渠道包时资源会自动进行替换。下面对应用图标做了替换。 3. 打包通过build/Generate Signed APK 打渠道包，可以全选，也可以打单个渠道。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android 资源分包]]></title>
    <url>%2F2017%2F04%2F06%2FAndroid-%E8%B5%84%E6%BA%90%E5%88%86%E5%8C%85%2F</url>
    <content type="text"><![CDATA[一直以为Android项目中的资源文件只能放在src/main/res的各个固定目录中。项目中的java代码可以根据功能模块创建不同的包来划分层次，资源文件则一般都放在res目录下。虽然可以通过命名规则区别不同模块的资源文件，但是随着业务的增长，开发人员的变动res目录会变得越来越繁杂。今天看到了一种资源分包的做法，感觉还不错，所以记录分享一下。 在build.gradle文件中可以配置资源文件的文件路径 123456789101112sourceSets &#123; main &#123; manifest.srcFile 'AndroidManifest.xml' java.srcDirs = ['src'] resources.srcDirs = ['src'] aidl.srcDirs = ['src'] renderscript.srcDirs = ['src'] res.srcDirs = ['res', 'res-ptr'] assets.srcDirs = ['assets'] jniLibs.srcDirs = ['libs'] &#125; &#125; 如上清单文件、jar等都可以自己指定目录，如下配置资源文件目录 12345sourceSets &#123; main &#123; res.srcDirs = ['src/main/res','src/main/res/mylayouts'] &#125; &#125; src/main/res为项目默认路径 src/main/res/mylayout为自定义路径（文件夹标识系统自动识别） 这种方式可以指定资源等文件夹，不过子文件夹得跟原来保持一致。例如图片文件放在mylayouts/drawable下、布局文件放在mylayout/layout下。]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[流式布局的使用]]></title>
    <url>%2F2016%2F12%2F04%2F%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[流式布局的使用 1.布局文件中的引用 123456&lt;com.example.administrator.swiperefreshlayout.FlowLayout android:id="@+id/flowLayout" android:layout_width="match_parent" app:horizontal_spacing="20dp" app:vertical_spacing="20dp" android:layout_height="wrap_content"&gt;&lt;/com.example.administrator.swiperefreshlayout.FlowLayout&gt; 代码中的引用 123456789101112FlowLayout flowLayout = (FlowLayout) findViewById(R.id.flowLayout); List&lt;String&gt; datas = new LinkedList&lt;String&gt;(); for (int i = 0; i &lt; 50; i++) &#123; if (i % 3 == 0) &#123; datas.add("-------========" + i); &#125; else datas.add("item" + i); View view = LayoutInflater.from(this).inflate(R.layout.flow_item, flowLayout, false); TextView textview = (TextView)view.findViewById(R.id.textview); textview.setText(datas.get(i)); flowLayout.addView(view); &#125; 3.FlowLayout的源码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122package com.liangfeizc.flowlayout;import android.content.Context;import android.content.res.TypedArray;import android.util.AttributeSet;import android.view.View;import android.view.ViewGroup;public class FlowLayout extends ViewGroup &#123; private static final int DEFAULT_HORIZONTAL_SPACING = 5; private static final int DEFAULT_VERTICAL_SPACING = 5; private int mVerticalSpacing; private int mHorizontalSpacing; public FlowLayout(Context context) &#123; super(context); &#125; public FlowLayout(Context context, AttributeSet attrs) &#123; super(context, attrs); TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.FlowLayout); try &#123; mHorizontalSpacing = a.getDimensionPixelSize( R.styleable.FlowLayout_horizontal_spacing, DEFAULT_HORIZONTAL_SPACING); mVerticalSpacing = a.getDimensionPixelSize( R.styleable.FlowLayout_vertical_spacing, DEFAULT_VERTICAL_SPACING); &#125; finally &#123; a.recycle(); &#125; &#125; public void setHorizontalSpacing(int pixelSize) &#123; mHorizontalSpacing = pixelSize; &#125; public void setVerticalSpacing(int pixelSize) &#123; mVerticalSpacing = pixelSize; &#125; @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) &#123; int myWidth = resolveSize(0, widthMeasureSpec); int paddingLeft = getPaddingLeft(); int paddingTop = getPaddingTop(); int paddingRight = getPaddingRight(); int paddingBottom = getPaddingBottom(); int childLeft = paddingLeft; int childTop = paddingTop; int lineHeight = 0; // Measure each child and put the child to the right of previous child // if there's enough room for it, otherwise, wrap the line and put the child to next line. for (int i = 0, childCount = getChildCount(); i &lt; childCount; ++i) &#123; View child = getChildAt(i); if (child.getVisibility() != View.GONE) &#123; measureChild(child, widthMeasureSpec, heightMeasureSpec); &#125; else &#123; continue; &#125; int childWidth = child.getMeasuredWidth(); int childHeight = child.getMeasuredHeight(); lineHeight = Math.max(childHeight, lineHeight); if (childLeft + childWidth + paddingRight &gt; myWidth) &#123; childLeft = paddingLeft; childTop += mVerticalSpacing + lineHeight; lineHeight = childHeight; &#125; else &#123; childLeft += childWidth + mHorizontalSpacing; &#125; &#125; int wantedHeight = childTop + lineHeight + paddingBottom; setMeasuredDimension(myWidth, resolveSize(wantedHeight, heightMeasureSpec)); &#125; @Override protected void onLayout(boolean changed, int l, int t, int r, int b) &#123; int myWidth = r - l; int paddingLeft = getPaddingLeft(); int paddingTop = getPaddingTop(); int paddingRight = getPaddingRight(); int childLeft = paddingLeft; int childTop = paddingTop; int lineHeight = 0; for (int i = 0, childCount = getChildCount(); i &lt; childCount; ++i) &#123; View childView = getChildAt(i); if (childView.getVisibility() == View.GONE) &#123; continue; &#125; int childWidth = childView.getMeasuredWidth(); int childHeight = childView.getMeasuredHeight(); lineHeight = Math.max(childHeight, lineHeight); if (childLeft + childWidth + paddingRight &gt; myWidth) &#123; childLeft = paddingLeft; childTop += mVerticalSpacing + lineHeight; lineHeight = childHeight; &#125; childView.layout(childLeft, childTop, childLeft + childWidth, childTop + childHeight); childLeft += childWidth + mHorizontalSpacing; &#125; &#125;&#125; 4.自定义的属性文件 values/styles1234&lt;declare-styleable name="FlowLayout"&gt; &lt;attr name="horizontal_spacing" format="dimension" /&gt; &lt;attr name="vertical_spacing" format="dimension" /&gt; &lt;/declare-styleable&gt;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于shape,selector style]]></title>
    <url>%2F2016%2F12%2F04%2F%E5%85%B3%E4%BA%8Eshape-selector-style%2F</url>
    <content type="text"><![CDATA[关于shape的讲解博客]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于MeasureSpec]]></title>
    <url>%2F2016%2F12%2F04%2F%E5%85%B3%E4%BA%8EMeasureSpec%2F</url>
    <content type="text"><![CDATA[视图view的大小是通过measure测量获取得到的,关于视图的测量我们有必要了解MeasureSpec这个类,官方API是这样描述的： 视图view的大小是通过measure测量获取得到的,关于视图的测量我们有必要了解MeasureSpec这个类,官方API是这样描述的： A MeasureSpec encapsulates the layout requirements passed from parent to child.Each MeasureSpec represents a requirement for either the width or the height. A MeasureSpec is comprised of a size and a mode. 通过简单翻译我们可以了解到： MesaureSpec这个类封装了父视图对子视图的布局要求,每个MeasureSpec代表了一个宽度或者高度的要求。MeasureSpec由测量模式和测量大小组成。 其中测量模式有以下三种 测量模式 特性 UNSPECIFIED The parent has not imposed any constraint on the child. It can be whatever size it wants. EXACTLY The parent has determined an exact size for the child. The child is going to be given those bounds regardless of how big it wants to be. AT_MOST The child can be as large as it wants up to the specified size. 为了节省内存MeasureSpec的设计也是很巧妙的 MeasureSpecs are implemented as ints to reduce object allocation.This class is provided to pack and unpack the &lt;size, mode&gt; tuple into the int. MeasureSpec通过32位的int类型来表示，其中高两位用来表示测量模式，后面30位是测量大小 看一下MeasureSpec的代码片段： 123456789101112131415161718192021222324252627public static class MeasureSpec &#123; private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 &lt;&lt; MODE_SHIFT;//三种测量模式，用int类型的高两位表示 public static final int UNSPECIFIED = 0 &lt;&lt; MODE_SHIFT; public static final int EXACTLY = 1 &lt;&lt; MODE_SHIFT; public static final int AT_MOST = 2 &lt;&lt; MODE_SHIFT; //通过传入测量尺寸和测量模式，自定义MeasureSpec public static int makeMeasureSpec(int size, int mode) &#123; if (sUseBrokenMakeMeasureSpec) &#123; return size + mode; &#125; else &#123; return (size &amp; ~MODE_MASK) | (mode &amp; MODE_MASK); &#125; &#125; //获取MeasureSpec的测量模式 public static int getMode(int measureSpec) &#123; return (measureSpec &amp; MODE_MASK); &#125; //获取MeasureSpec的测量大小 public static int getSize(int measureSpec) &#123; return (measureSpec &amp; ~MODE_MASK); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>自定义view</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识小程序]]></title>
    <url>%2F2016%2F10%2F11%2F%E5%88%9D%E8%AF%86%E5%B0%8F%E7%A8%8B%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[初始小程序 初识小程序小程序资源链接官方文档开发工具下载官方Demo源码下载设计指南 开发步骤 获取小程序的AppID 创建项目 编写代码 调试预览程序目录结构介绍 名称 属性 作用 app.js 脚本文件 监听小程序生命周期、声明全局变量、调用框架的API app.json 配置文件 界面page的注册、窗口背景色设置、导航条样式、标题等 app.wxss 样式表文件 css小程序的公共样式表 page 界面文件夹 每个界面的具体配置 app.js123456789101112App(&#123; onLaunch: function() &#123; // Do something initial when launch. &#125;, onShow: function() &#123; // Do something when show. &#125;, onHide: function() &#123; // Do something when hide. &#125;, globalData: 'I am global data'&#125;) app.json.json文件中不支持注释12345678910111213141516171819202122232425262728//界面注册默认第一个为启动页&#123; "pages": [ "pages/index/index", "pages/logs/index" ], //窗口背景，标题等设置 "window": &#123; "navigationBarTitleText": "Demo" &#125;, //导航栏设置（2-5个） "tabBar": &#123; "list": [&#123; "pagePath": "pages/index/index", "text": "首页" &#125;, &#123; "pagePath": "pages/logs/logs", "text": "日志" &#125;] &#125;, //网络设置 "networkTimeout": &#123; "request": 10000, "downloadFile": 10000 &#125;, //调试模式 "debug": true&#125; app.wxss123456/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125; page目录结构介绍page由四个同名不同后缀的文件组成 名称 属性 作用 .js 脚本文件 页面的初始化、声明周期函数、事件处理 .json 配置文件 页面配置文件，非必须重写app.json .wxss 样式表文件 页面样式文件，非必须重写app.wxss .wxml 页面结构文件 使用组件绘制界面 .js123456789101112131415161718192021222324252627282930313233343536Page(&#123;//data 将会以 JSON 的形式由逻辑层传至渲染层.wxml data:&#123; // text:&quot;这是一个页面&quot; &#125;, onLoad:function(options)&#123; // 页面初始化 options为页面跳转所带来的参数 &#125;, onReady:function()&#123; // 页面渲染完成 &#125;, onShow:function()&#123; // 页面显示 &#125;, onHide:function()&#123; // 页面隐藏 &#125;, onUnload:function()&#123; // 页面关闭 &#125; // 监听按键点击 onSearchClick: function (event) &#123; var that=this; saveSearchHistory(that,this.data.searchText); toSearchResult(this.data.searchText); &#125;,&#125;)//跳转搜索结果页function toSearchResult(searchtext) &#123; wx.navigateTo(&#123; url:&apos;../searchresultpanel/searchresultpanel?text=&apos;+searchtext &#125;)&#125; .json1234//重写导航标题&#123; "navigationBarTitleText": "WeXin"&#125; .wxss123456/**index.wxss**/.userinfo &#123; display: flex; flex-direction: column; align-items: center;&#125; .wxml12345678&lt;!--数据绑定使用 Mustache 语法（双大括号）将变量包起来，同时可以进行逻辑运算--&gt;&lt;view&gt; &#123;&#123;message&#125;&#125; &lt;/view&gt;&lt;!--条件渲染--&gt;&lt;view wx:if="&#123;&#123;condition&#125;&#125;"&gt; True &lt;/view&gt;&lt;!--列表渲染--&gt;&lt;view wx:for="&#123;&#123;items&#125;&#125;"&gt; &#123;&#123;index&#125;&#125;: &#123;&#123;item.message&#125;&#125;&lt;/view&gt; 模块化js的模块化 我们可以将一些公共的代码抽离成为一个单独的 js 文件，作为一个模块。模块只有通过 module.exports 才能对外暴露接口。 1234567// common.jsfunction sayHello(name) &#123; console.log(&apos;Hello &apos; + name + &apos;!&apos;)&#125;module.exports = &#123; sayHello: sayHello&#125; 在需要使用这些模块的文件中，使用 require(path) 将公共代码引入。 123456var common = require(&apos;common.js&apos;)Page(&#123; helloMINA: function() &#123; common.sayHello(&apos;MINA&apos;) &#125;&#125;) wxml的引用 WXML 提供两种文件引用方式import和include。 import import 有作用域的概念，即只会 import 目标文件中定义的 template，而不会 import 目标文件 import 的 template。 12345678910在 item.wxml 中定义了一个叫item的template：&lt;!-- item.wxml --&gt;&lt;template name=&quot;item&quot;&gt; &lt;text&gt;&#123;&#123;text&#125;&#125;&lt;/text&gt;&lt;/template&gt;在 index.wxml 中引用了 item.wxml，就可以使用item模板：&lt;import src=&quot;item.wxml&quot;/&gt;&lt;template is=&quot;item&quot; data=&quot;&#123;&#123;text: &apos;forbar&apos;&#125;&#125;&quot;/&gt; include include可以将目标文件除了&lt;template/&gt;的整个代码引入，相当于是拷贝到include位置. 12345678&lt;!-- index.wxml --&gt;&lt;include src=&quot;header.wxml&quot;/&gt;&lt;view&gt; body &lt;/view&gt;&lt;include src=&quot;footer.wxml&quot;/&gt;&lt;!-- header.wxml --&gt;&lt;view&gt; header &lt;/view&gt;&lt;!-- footer.wxml --&gt;&lt;view&gt; footer &lt;/view&gt; wxss样式的导入 使用@import语句可以导入外联样式表，@import后跟需要导入的外联样式表的相对路径，用;表示语句结束。 123456789/** common.wxss **/.small-p &#123; padding:5px;&#125;/** app.wxss **/@import &quot;common.wxss&quot;;.middle-p &#123; padding:15px;&#125; 接口和组件 接口和组件参考官方文档和官方Demo源码 开发工具介绍调试模块Wxml pannel Wxml panel 用于帮助开发者开发 Wxml 转化后的界面。在这里可以看到真实的页面结构以及结构对应的 wxss 属性，同时可以通过修改对应 wxss 属性，在模拟器中实时看到修改的情况。通过调试模块左上角的选择器，还可以快速找到页面中组件对应的 wxml 代码。 Sources pannel Sources panel 用于显示当前项目的脚本文件，同浏览器开发不同，微信小程序框架会对脚本文件进行编译的工作，所以在 Sources panel 中开发者看到的文件是经过处理之后的脚本文件，开发者的代码都会被包裹在 define 函数中，并且对于 Page 代码，在尾部会有 require 的主动调用。 Network pannel Netwrok Pannle 用于观察和显示 request 和 socket 的请求情况 Appdata pannel Appdata panel 用于显示当前项目当前时刻 appdata 具体数据，实时地反馈项目数据情况，可以在此处编辑数据，并及时地反馈到界面上。 Storage pannel Storage panel 用于显示当前项目的使用 wx.setStorage 或者 wx.setStorageSync 后的数据存储情况。 Console pannel 输入和调试代码，错误日志的显示 开发中遇到的问题总结js代码的引入../类似于cd ..返回上一层目录1var netUtils = require('../../../utils/netUtils.js') 布局问题flex布局介绍 事件的响应处理和传值事件详解介绍 事件列表 类型 触发条件 touchstart 手指触摸 touchmove 手指触摸后移动 touchcancel 手指触摸动作被打断，如来电提醒，弹窗 touchend 手指触摸动作结束 tap 手指触摸后离开 longtap 手指触摸后，超过350ms再离开 事件分类 事件 声明方法 作用 冒泡事件 bind+事件 当一个组件上的事件被触发后，该事件会向父节点传递 非冒泡事件 catch+事件 当一个组件上的事件被触发后，该事件不会向父节点传递 data的数据设置 直接修改 this.data 无效，无法改变页面的状态，还会造成数据不一致。 单次设置的数据不能超过1024kB，请尽量避免一次设置过多的数据。 12345that.setData(&#123; categoryList: that.data.categoryList.concat(categoryList), hideLoading: true, isLoadingMore:false &#125;)]]></content>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apk的安装卸载等操作介绍]]></title>
    <url>%2F2016%2F09%2F19%2FApk%E7%9A%84%E5%AE%89%E8%A3%85%E5%8D%B8%E8%BD%BD%E7%AD%89%E6%93%8D%E4%BD%9C%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[通过包名实现程序的打开、卸载、更新等操作，apk文件的安装等 监听程序的安装和卸载在清单文件中注册广播，添加过滤器 1234567891011&lt;receiver android:name=".kit.packManager.PackReceiver" android:label="PackReceiver"&gt; &lt;intent-filter&gt; &lt;action android:name="android.intent.action.PACKAGE_ADDED" /&gt; &lt;action android:name="android.intent.action.PACKAGE_REPLACED" /&gt; &lt;action android:name="android.intent.action.PACKAGE_REMOVED" /&gt; &lt;data android:scheme="package" /&gt; &lt;/intent-filter&gt; &lt;/receiver&gt; 在接收到广播时进行相应的操作 12//获取发送广播的包名 String packName = intent.getData().getSchemeSpecificPart(); 通过Action判断当前的包操作 Action 操作 Intent.ACTION_PACKAGE_ADDED 安装 Intent.ACTION_PACKAGE_REPLACED 更新 Intent.ACTION_PACKAGE_REMOVED 卸载 通过包名打开程序1234Intent intent = context.getPackageManager().getLaunchIntentForPackage(packName); if (intent != null) &#123; context.startActivity(intent); &#125; 通过apk目录安装程序1234Intent intent = new Intent(Intent.ACTION_VIEW); intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent.setDataAndType(Uri.parse("file://" + packPath), "application/vnd.android.package-archive"); context.startActivity(intent); 通过包名卸载程序12345Intent intent = new Intent(); intent.setAction(Intent.ACTION_DELETE); intent.setData(Uri.parse("package:" + packName)); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent);]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Service]]></title>
    <url>%2F2016%2F09%2F18%2FService%2F</url>
    <content type="text"><![CDATA[认识Service无UI页面的，并长期处理后台运行，其所在的进程状态为服务进程 ,它本身在主线程执行。它的主要作用用于管理生命周期较长的组件，如带有子线程管理的MediaPlayer、定时器等。 通过startService()启动服务 新建Service的子类，重写一个抽象方法（onBind( )），和三个核心的生命周期方法 onCreate()，onStartCommand()， onDestroy()。通过日志观察服务的生命周期 。Ps:服务需要到清单文件中注册 12345678910111213141516171819202122232425262728293031323334public class MyService extends Service &#123; private static final String TAG = MyService.class.getName(); public MyService() &#123; &#125; @Override public void onCreate() &#123; super.onCreate(); Log.d(TAG,"onCreate"); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; Log.d(TAG,"onStartCommand"); return super.onStartCommand(intent, flags, startId); &#125; @Override public IBinder onBind(Intent intent) &#123; // TODO: Return the communication channel to the service. throw new UnsupportedOperationException("Not yet implemented"); &#125; @Override public void onDestroy() &#123; super.onDestroy(); Log.d(TAG,"onDestroy"); &#125;&#125; 通过startService()启动服务，通过stopService()停止服务 123456789101112131415startService.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent = new Intent(v.getContext(), MyService.class); startService(intent); &#125; &#125;); findViewById(R.id.btn_stop_service).setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Intent intent=new Intent(v.getContext(),MyService.class); stopService(intent); &#125; &#125;); 运行日志如下 12344-12 14:56:26.707 28721-28721/com.violin.violindemo D/com.violin.service.MyService: onCreate04-12 14:56:26.709 28721-28721/com.violin.violindemo D/com.violin.service.MyService: onStartCommand04-12 14:58:36.542 28721-28721/com.violin.violindemo D/com.violin.service.MyService: onStartCommand04-12 14:59:19.694 28721-28721/com.violin.violindemo D/com.violin.service.MyService: onDestroy 服务的创建onCreate()和销毁onDestory()只执行一次，执行多少次content.startService()服务里的onStartCommand()就会被调用几次 context.startService–&gt;onCreat()(只执行一次)–&gt;onstartCommand()–&gt;Service Running–&gt;context.stopService()–&gt;onDestory()(只执行一次)–&gt;Service Stop 通过bindService()启动服务 通过startService()方法启动服务后，服务将一直处于运行状态，但是具体的运行逻辑Activity控制不了。如果需要实现Service和Activity中间的交互，需要通过bindService()方式启动。 新建MyService的时候会重写onBind()方法，上面通过startService()方式启动并不会调用此方法，只用通过bindService()方法启动，在Actiivty和Service之间绑定时onBind()方法才会被调用。 新建MyBindler类继承Binder，在类中定义Activity操作Service的方法，例如现在要实现播放功能： 1234567891011121314151617class MyBindler extends Binder &#123; public void init() &#123; &#125; public void play() &#123; &#125; public int getProgress() &#123; return 0; &#125; public void stop() &#123; &#125; &#125; 在MyService的onBind()方法中返回MyBindler对象 12345678... @Override public IBinder onBind(Intent intent) &#123; Log.d(TAG, "onBind"); MyBindler myBindler = new MyBindler(); return myBindler; &#125; ... 在Activity 中定义MyBindler对象，并在服务绑定时完成初始化 12345678910111213141516private MyService.MyBindler mProgressBindler; private ServiceConnection mServiceConnection = new ServiceConnection() &#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; Log.d("whl", "onServiceConnected"); mProgressBindler = (MyService.MyBindler) service; &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; Log.d("whl", "onServiceDisconnected"); &#125; &#125;; 通过bindService()方法绑定服务通过bindService启动的Service不会调用onStartCommand()方法 123Intent intent = new Intent(v.getContext(), MyService.class);// 绑定服务的类型和作用在后面列表中列出bindService(intent, mServiceConnection, BIND_AUTO_CREATE); 绑定服务成功后会回调onServiceConnected()方法，同时返回Service中的MyBindler对象。这时Activity就可以通过初始化好的MyBinder对象操控Service。 通过unBindService()方法解绑服务 1unbindService(mServiceConnection); context.bindService–&gt;onCreat()(只执行一次)–&gt;onBind()(只绑定一次)–&gt;ServiceRunning–&gt;onUnBind()–&gt;onDestory()(只执行一次)–&gt;Service Stop PS:可以通过Service.stopSelf()方法或者Service.stopSelfResult()方法来停止自己，只要调用一次stopService()方法便可以停止服务，无论调用了多少次的启动服务方法 绑定的服务类型 名称 作用 BIND_AUTO_CREATE 绑定的service不存在时，会自动创建 BIND_ADJUST_WITH_ACTIVITY service的优先级别与根据所绑定的Activity的重要程度有关，Activity处于前台，service的级别高 BIND_NOT_FOREGROUND Service永远不拥有运行前台的优先级 BIND_WAIVE_PRIORITY Service的优先级不会改变 BIND_IMPORTANT&amp;BIND_ABOVE_CLIENT 所绑定的Activity处于前台时，Service也处于前台BIND_ABOVE_CLIENT 指定内存很低的情况下，运行时在终止绑定的Service之前终止Activity IntentService IntentService是带有子线程的服务组件，内部通过HandlerThread实现 当所有的任务执行完成后，会自动关闭本服务 其生命周期方法： onCreate() onStartCommand() onHandleIntent() 在子线程中执行的方法 onDestroy()创建IntentService子类时，需要提供一个无参的构造方法且调用super(name)子线程的名称，如果没有无参数的构造方法清单文件注册Service时会报错 不建议通过bindService来启动IntentService,因为IntentService是在子线程中执行，而且bindService()启动不会执行onStartCommand()方法，没有了IntentService的设计初衷 粘性Service 通过在onstartCommand()方法中返回不同的Service标记创建不同的粘性Service 标签 作用 START_STICKY 粘性标识 如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null START_NOT_STICKY 非粘性标识 “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。 START_REDELIVER_INTENT 带数据的粘性标识 重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
        <tag>Service</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Android_M新特性]]></title>
    <url>%2F2016%2F09%2F18%2FAndroid-M%E6%96%B0%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[Android5.0中添加了很多MD风格的控件，现在简单了解下各个控件的作用和使用效果Android M MD风格的介绍 Snackbar Snackbar提供了一个介于Toast和AlertDialog之间轻量级控件，它可以很方便的提供消息的提示和动作反馈。 12345678Snackbar snackbar = Snackbar.make(inputLayout,"测试弹出提示",Snackbar.LENGTH_LONG); snackbar.show(); snackbar.setAction("取消",new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; snackbar.dismiss(); &#125; &#125;); TextInputLayout 具有MD风格的文本输入框父布局 1搭配EditText使用，显示错误信息的提示 FloatingActionButton悬浮按键FAB继承者ImageView TabLayout 标签布局搭配ViewPager使用 NavigationView导航布局实现抽屉效果搭配DrawerLayout使用 CoordinatorLayout 继承自FrameLayoutAppBarLayout 继承自LinerLayout 实现滑动的效果需要两种布局组合CoordinatorLayout 作为整体的父布局 AppBarLayout布局，作为滑动视图的父布局 可滑动的VIew(RecyclerView)需要设置app:layout_behavior=”@string/appbar_scrolling_view_behavior”属性设置后该布局会自动放在AppBarLayout的下面 在AppBarLayout中放置你想滚动的视图，并设置相应的滚动属性，如果里面放在的是嵌套的布局文件的话，只对最外面的根局有效属性有四种：app:layout_scrollFlags=”scroll|enterAlways” scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能已最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 滚动退出屏幕，最后折叠在顶端。 加入可折叠的属性CollapsingToolbarLayoutCollapsingToolbarLayout包裹 Toolbar 的时候提供一个可折叠的 Toolbar，一般作为AppbarLayout的子视图使用。如果CollapsingToolbarLayout 中不显示添加ToolBar这应该在CollapsingToolbarLayout 中设置 android:minHeight=”40dp”也可以达到折叠的效果]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Activity]]></title>
    <url>%2F2016%2F09%2F18%2FActivity%2F</url>
    <content type="text"><![CDATA[Activity 生命周期 多Activity启动生命周期 Activity生命周期顺序执行如上，如果A启动B，在B界面再退回A两个Activity的生命周期会如何调用，下面简单验证下 启动App,MainActivity创建生命周期如下 123D/Activity: MainActivity onCreateD/Activity: MainActivity onStartD/Activity: MainActivity onResume 从MainActivity启动SecondActivity 从日志可以看出MainActivity会先走onPause()方法，等SecondActivity界面走完创建流程，到onResume()之后，前一个界面才会走onStop()方法 12345D/Activity: MainActivity onPauseD/Activity: SecondActivity onCreateD/Activity: SecondActivity onStartD/Activity: SecondActivity onResumeD/Activity: MainActivity onStop 从SecondActivity退回到MainActivity 当上一个界面MainActivity重新onResume()后，SecondActivity才会调onStop(),onDestory()方法 12345D/Activity: SecondActivity onPauseD/Activity: MainActivity onStartD/Activity: MainActivity onResumeD/Activity: SecondActivity onStopD/Activity: SecondActivity onDestroy 从日志也可以看出无论从A启动到B,还是从B退回到A,当前显示的Activity会先走onPause()方法，目标Activity才会走创建或者重新回到前台流程。所以onPause()方法中不适合做一些耗时操作，会影响下一个界面的打开。 Activity 启动模式 onNewIntent方法的执行时机1当此Activity的实例已经存在，并且此时的启动模式为SingleTask和SingleInstance，另外当这个实例位于栈顶且启动模式为SingleTop时也会触发onNewInstent()。 Activity 启动异常 通过隐式意图启动Activity时需要处理一些异常情况，例如目标Activity不存在、没有打开权限等。 Permission Denial 打开目标Activity权限失败，例如目标Activity中设置了下面参数 1android:exported="false" 具体错误信息 1Permission Denial: starting Intent &#123; act=android.intent.action.VIEW dat=plugin:// flg=0x10200000 cmp=cn.qbzsydsq.reader/demo.ad.dy.com.appdemo.plugin.PluginActivity &#125; from ProcessRecord&#123;80c0b66 26467:com.violin.violindemo/u0a931&#125; (pid=26467, uid=10931) not exported from uid 11016 No Activity found to handle Intent 手机上没有找到处理意图的目标Activity 具体错误信息 1android.content.ActivityNotFoundException: No Activity found to handle Intent &#123; act=android.intent.action.VIEW dat=plugi:// flg=0x10200000 &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Activity</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AsyncTask]]></title>
    <url>%2F2016%2F09%2F18%2FAsyncTask%2F</url>
    <content type="text"><![CDATA[AsyncTack是对Thread+Handler良好的封装，用来执行异步任务 三种泛型参数类型分别代表“启动任务执行的输入参数”、“后台任务执行的进度”、“后台计算结果的类型”。在特定场合下，并不是所有类型都被使用，如果没有被使用，可以用java.lang.Void类型代替。 1public abstract class AsyncTask&lt;Params, Progress, Result&gt; 一个异步任务的执行一般包括以下几个步骤： execute(Params… params)，执行一个异步任务，需要我们在代码中调用此方法，触发异步任务的执行。 onPreExecute()，在execute(Params… params)被调用后立即执行，一般用来在执行后台任务前对UI做一些标记。 doInBackground(Params… params)，在onPreExecute()完成后立即执行，用于执行较为费时的操作，此方法将接收输入参数和返回计算结果。在执行过程中可以调用publishProgress(Progress… values)来更新进度信息。在子线程中执行 onProgressUpdate(Progress… values)，在调用publishProgress(Progress… values)时，此方法被执行，直接将进度信息更新到UI组件上。 onPostExecute(Result result)，当后台操作结束时，此方法将会被调用，计算结果将做为参数传递到此方法中，直接将结果显示到UI组件上。 在使用的时候，有几点需要格外注意：1.异步任务的实例一般在UI线程中创建。（它的内部使用Handler实现，需要Looper对象,也可以子线程中调用，后面会介绍到） 2.execute(Params… params)方法必须在UI线程中调用。 3.不要手动调用onPreExecute()，doInBackground(Params… params)，onProgressUpdate(Progress… values)，onPostExecute(Result result)这几个方法。 4.不能在doInBackground(Params… params)中更改UI组件的信息。 5.一个任务实例只能执行一次，如果执行第二次将会抛出异常。 补充 使用execute(),启动异步任务，任务串行执行（一个执行完才会执行另一个任务）源码实现如下 1234567891011121314151617181920212223242526272829public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125; @MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125; execute()方法的具体实现实在executeOnExecutor()方法中， onPreExecute()方法也在此处调用。任务的具体执行则在sDefaultExecutor中，这是一个SerialExecutor类型，源码如下 12345678910111213141516171819202122232425private static class SerialExecutor implements Executor &#123; final ArrayDeque&lt;Runnable&gt; mTasks = new ArrayDeque&lt;Runnable&gt;(); Runnable mActive; public synchronized void execute(final Runnable r) &#123; mTasks.offer(new Runnable() &#123; public void run() &#123; try &#123; r.run(); &#125; finally &#123; scheduleNext(); &#125; &#125; &#125;); if (mActive == null) &#123; scheduleNext(); &#125; &#125; protected synchronized void scheduleNext() &#123; if ((mActive = mTasks.poll()) != null) &#123; THREAD_POOL_EXECUTOR.execute(mActive); &#125; &#125; &#125; 如上，executeOnExecutor()中调用exec.execute(mFuture)方法，具体执行在SerialExecutor的public synchronized void execute(final Runnable r)方法中。它把每个任务添加到mTasks中，然后通过scheduleNext（）方法取出任务，并通过THREAD_POOL_EXECUTOR线程池来执行。每个任务的运行通过try catch处理，无论上个任务的运行结果，scheduleNext()都会在finally()中执行。SerialExecutor用来保证任务是串行执行。 使用 task.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,”Task”+i);启动异步任务，任务会并发执行（多个任务一起执行） executeOnExecutor()启动方法会绕过SerialExecutor的逻辑，线程池会直接执行任务，并发的任务可以通过线程池控制，也可以自定义线程池 AsyncTask 不适合耗时任务 AsyncTask 中任务的具体执行是通过 threadPoolExecutor 线程池，如下，非核心线程的超时时间为 3s,此外默认任务是串行执行，如果多个耗时任务的话效率也会比较低。123456789101112 private static final int CORE_POOL_SIZE = 1; private static final int MAXIMUM_POOL_SIZE = 20; private static final int BACKUP_POOL_SIZE = 5; private static final int KEEP_ALIVE_SECONDS = 3; static &#123; ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor( CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE_SECONDS, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;(), sThreadFactory); threadPoolExecutor.setRejectedExecutionHandler(sRunOnSerialPolicy); THREAD_POOL_EXECUTOR = threadPoolExecutor; &#125; 子线程中是否可以启动AsyncTask？ 可以启动，但是onPreExecute的方法执行在execute()的调用线程,doInBackground()方法仍然在线程池新建的线程中执行onProgressUpdate()、onPostExecute()等其他通过handler机制回调的方法则在主线程中执行。AsyncTask 是Handler和Thread的封装，创建任务时Looper是主线程的就不影响执行过程。不过最好还是按照官方文档在主线程中执行。AsyncTask 提供了三个构造方法，可供外部使用的只有无参的那个，具体初始化是在传参为Loop类型的构造器中。如代码，无论在哪个线程中启动，mHandler 中的Looper都是Looper.getMainLooper()。 123456789101112131415161718192021222324252627282930 /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. */ public AsyncTask() &#123; this((Looper) null); &#125; /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * * @hide */ public AsyncTask(@Nullable Handler handler) &#123; this(handler != null ? handler.getLooper() : null); &#125; /** * Creates a new asynchronous task. This constructor must be invoked on the UI thread. * * @hide */ public AsyncTask(@Nullable Looper callbackLooper) &#123; mHandler = callbackLooper == null || callbackLooper == Looper.getMainLooper() ? getMainHandler() : new Handler(callbackLooper); ... ... ...&#125; onPreExecute的方法执行在execute()的调用线程。 1234567891011121314151617181920212223242526272829@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; execute(Params... params) &#123; return executeOnExecutor(sDefaultExecutor, params); &#125;@MainThread public final AsyncTask&lt;Params, Progress, Result&gt; executeOnExecutor(Executor exec, Params... params) &#123; if (mStatus != Status.PENDING) &#123; switch (mStatus) &#123; case RUNNING: throw new IllegalStateException("Cannot execute task:" + " the task is already running."); case FINISHED: throw new IllegalStateException("Cannot execute task:" + " the task has already been executed " + "(a task can be executed only once)"); &#125; &#125; mStatus = Status.RUNNING; onPreExecute(); mWorker.mParams = params; exec.execute(mFuture); return this; &#125;]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于TextViewt的使用技巧]]></title>
    <url>%2F2016%2F09%2F17%2F%E5%85%B3%E4%BA%8ETextViewt%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[设置TextView文字不同颜色1text.setText(Html.fromHtml("&lt;font color=\'#858585\'&gt;购买前如有任何疑问，欢迎使用：&lt;/font&gt;&lt;font color=\'#f02387\'&gt;&lt;U&gt;购物咨询&lt;/U&gt;&lt;/font&gt;"));]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于EditText的使用技巧]]></title>
    <url>%2F2016%2F09%2F17%2F%E5%85%B3%E4%BA%8EEditText%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[键盘唤起后遮挡输入框1在清单文件的相应Activity下添加 android:windowSoftInputMode=&quot;adjustPan&quot;属性 修改键盘右下角响应按键 修改成完成，也可以修改成搜索等 1`android:imeOptions=&quot;actionDone&quot;` 监听键盘右下角响应按键事件 以响应完成为例actionId == EditorInfo.IME_ACTION_DONE 12345678editText.setOnEditorActionListener(new TextView.OnEditorActionListener() &#123; @Override public boolean onEditorAction(TextView v, int actionId, KeyEvent event) &#123; if (actionId == EditorInfo.IME_ACTION_DONE) &#123; return false; &#125; &#125;);]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Volley]]></title>
    <url>%2F2016%2F09%2F17%2FVolley%2F</url>
    <content type="text"><![CDATA[Volley特别适合数据量不大但是通信频繁的场景,对于大数据的加载并不适用 Volley请求json数据 声明RequestQueue 1mRequestQueue = Volley.newRequestQueue(this); 声明并使用Request 12345678910111213141516JsonObjectRequest jr = new JsonObjectRequest(Request.Method.GET,url,null,new Response.Listener&lt;JSONObject&gt;() &#123; @Override public void onResponse(JSONObject response) &#123; Log.i(TAG,response.toString()); parseJSON(response); va.notifyDataSetChanged(); pd.dismiss(); &#125; &#125;,new Response.ErrorListener() &#123; @Override public void onErrorResponse(VolleyError error) &#123; Log.i(TAG,error.getMessage()); &#125; &#125;); //将请求添加到请求队列 mRequestQueue.add(jr); Volley提供了JsonObjectRequest、JsonArrayRequest、StringRequest等Request形式。 请求方式 返回对象 JsonObjectRequest 返回JSON对象 JsonArrayRequest 返回JsonArray StringRequest 返回String 另外可以继承Request自定义Request。 Volley图片加载使用ImageRequest下载图片 Volley提供了多种Request方法，ImageRequest能够处理单张图片，返回bitmap。下面是ImageRequest的使用例子，和JsonRequest的一样。 123456789101112131415161718singleImg=(ImageView)findViewById(R.id.volley_img_single_imgeview); ImageRequest imgRequest=new ImageRequest(url, new Response.Listener&lt;Bitmap&gt;() &#123; @Override public void onResponse(Bitmap arg0) &#123; // TODO Auto-generated method stub singleImg.setImageBitmap(arg0); &#125; //参数3/4: 内存中Bitmap 最大的宽/高度限制，用于降低内存的消耗 // 参数5：告诉 BitmapFactory，在生成Bitmap的时候，一个像素，包含的信息 //Config.ARGB_8888标识argb各占8个位，即一个像素4个字节 &#125;, 300, 200, Config.ARGB_8888, new ErrorListener()&#123; @Override public void onErrorResponse(VolleyError arg0) &#123; // TODO Auto-generated method stub &#125; &#125;); mRequestQueue.add(imgRequest); 使用ImageLoader加载图片 ImageLoader这个类需要一个Request的实例以及一个ImageCache的实例。图片通过一个URL和一个ImageListener实例的get()方法就可以被加载。ImageLoader会检查ImageCache,如果缓存里没有图片就会从网络上获取。ImageCache接口有两个方法，getBitmap(String url)和putBitmap(String url, Bitmap bitmap).这两个方法足够简单直白，他们可以添加任何的缓存实现。ImageCache和LruCache（最近最少使用算法）缓存一起使用缓存图片 LruCache 构造⽅方法，如果 LruCache 重写了sizeOf()，那么构造参数 代表 占⽤用的最⼤ 内存尺⼨； 如果 LruCache 不重写 sizeOf（），代表 最多能够存多少个对象；123456789101112131415161718192021222324252627282930 RequestQueue mRequestQueue = Volley.newRequestQueue(this); final LruCache&lt;String, Bitmap&gt; mImageCache = new LruCache&lt;String, Bitmap&gt;(20*1024*1024)&#123; @Override protected int sizeOf(String key, Bitmap value) &#123; return value.getRowBytes()*value.getHeight(); &#125; &#125;;&#125;; ImageCache imageCache = new ImageCache() &#123; @Override public void putBitmap(String key, Bitmap value) &#123; mImageCache.put(key, value); &#125; @Override public Bitmap getBitmap(String key) &#123; return mImageCache.get(key); &#125; &#125;; ImageLoader mImageLoader = new ImageLoader(mRequestQueue, imageCache); // imageView是一个ImageView实例 // ImageLoader.getImageListener的第二个参数是默认的图片resource id // 第三个参数是请求失败时候的资源id，可以指定为0 ImageListener listener = ImageLoader .getImageListener(imageView, android.R.drawable.ic_menu_rotate, android.R.drawable.ic_delete); mImageLoader.get(url, listener); 使用NetWorkImageView加载图片 Volley中提供的ui控件，继承ImageView这个控件在被从父控件detach的时候，会自动取消网络请求的，即完全不用我们担心相关网络请求的生命周期问题。这里也会用到ImageLoadr 12setImageUrl(String url,ImageLoader imageLoader) 设置图片资源setDefaultImageResId(int resId) 设置默认图片 VolleyVolley取消下载请求 Activity被终止之后，如果继续使用其中的Context等，除了无辜的浪费CPU，电池，网络等资源，有可能还会导致程序crash，所以，我们需要处理这种一场情况。使用Volley的话，我们可以在Activity停止的时候，同时取消所有或部分未完成的网络请求。 取消请求集合里的所有请求1234567@Override public void onStop() &#123; for (Request &lt;?&gt; req : mInFlightRequests) &#123; req.cancel(); &#125; ... &#125; 取消队列里的所有请求12345678910111213 @Override pubic void onStop() &#123; mRequestQueue.cancelAll(this); ... &#125; ``` ### 根据RequestFilter或者Tag来终止某些请求```java @Override public void onStop() &#123; mRequestQueue.cancelAll( new RequestFilter() &#123;&#125;) ... // or mRequestQueue.cancelAll(new Object()); ... Volley的设计架构 Volley使用了线程池来作为基础结构，主要分为主线程，cache线程和network线程。 主线程和cache线程都只有一个，而NetworkDispatcher线程可以有多个，如下图:]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[日常小总结]]></title>
    <url>%2F2016%2F09%2F13%2F%E6%97%A5%E5%B8%B8%E5%B0%8F%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[此篇博客用于日常的知识点的总结，不定时更新。 关于GradleGradle 介绍 Andtoid Studio的编译和打包依赖于Gradle脚本，Gradle的版本不同经常会导致导入程序无法运行。 Mac上会默认下载到/Users/&lt;用户名&gt;/.gradle/wrapper/dists Windows会默认下载到C:\Documents and Settings\&lt;用户名&gt;.gradle\wrapper\dists AS清除gradle 依赖缓存 如果将依赖库上传到maven或者jcenter,开发过程中可能修改一些小问题重新上传到maven,如果版本号没有修改，项目在拉取依赖库时gradle会使用本地缓存的那一份导致代码不能及时更新。如果有这种修改了代码但是不想升级版本号的需求可以使用下面命令清除本地缓存 12345678Windows: gradlew build --refresh-dependencies Mac:./gradlew build --refresh-dependencies //如果mac上输入上面命令 有 Permission Denied 的提示 加入下面命令在重新执行chmod +x gradlew 关于Git已经被git管理的文件，重新添加到忽略中 git rm -r –cached [文件] 配置忽略文件 重新提交 一些SDK工具 aapt用来查看apk包的包名、版本名称、启动Activity等一些信息。 1aapt dump badging [.apk] 证书信息查询 查看apk的签名证书的MD5等信息 1keytool -list -v -alias ‘别名（可不加）’ -keystore [.keystore] ImageView ImageView 设置最大宽高无作用问题修复 12 android:maxHeight="200dp"android:adjustViewBounds="true" TextView TextView 设置图片setCompoundDrawables()注意事项 1234Drawable drawable = getResources().getDrawable(iconId);// 需要设置setBounds()方法，否则图片设置失败drawable.setBounds(0, 0, drawable.getMinimumWidth(), drawable.getMinimumHeight());textView.setCompoundDrawables(drawable, null, null, null); Error: Expected resource of type styleable [ResourceType] 这个错误在编译运行是没有问题，当打release包是会报错。位置在TypedArray获取属性值时。解决方法是在方法上添加@SuppressWarnings(&quot;ResourceType&quot;) 1234567@SuppressWarnings("ResourceType")public void initView() &#123; TypedArray ta = mContext.obtainStyledAttributes(attrs); mStatusBarAvailable = a.getBoolean(0, false); mNavBarAvailable = a.getBoolean(1, false); ta.recycle();&#125; 软键盘问题 开发中我们常遇到的键盘问题有两种：1. 进入界面时键盘的自动弹出或隐藏；2. 键盘弹出后遮挡视图问题。解决这些问题可以在清单文件中设置&lt;activity android:windowSoftInputMode=&quot;stateVisible|adjustResize&quot; . . . &gt; 属性，也可以在代码中通过getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);方法实现。具体参考官方文档 弹出键盘遮住视图 键盘覆盖在视图上面，视图不上移 123&lt;activity android:name=".activity.MainActivity" android:screenOrientation="portrait" android:windowSoftInputMode="adjustPan"/&gt; 弹出键盘把屏幕顶上去1this.getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE); 关闭软键盘方法123InputMethodManager imm = (InputMethodManager) view.getContext().getSystemService(Context.INPUT_METHOD_SERVICE); //关闭软键盘 imm.hideSoftInputFromWindow(view.getWindowToken(), 0); bitmap标签图片拉伸问题在xml文件中引入bitmap标签，默认情况下bitmap引入的图片资源会根据所在的控件大小进行强制拉伸，为了避免这种情况可以通过gravity属性设置图片不拉伸 12345678910&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;layer-list xmlns:android="http://schemas.android.com/apk/res/android"&gt; &lt;item &gt; &lt;bitmap android:gravity="top|fill_horizontal" android:src="@drawable/bg_home" /&gt; &lt;/item&gt;&lt;/layer-list&gt; 错误：Error:Execution failed for task &#39;:app:transformClassesWithDexForDebug&#39;. 第三方依赖jar包重复依赖造成的问题 1234defaultConfig &#123; ... multiDexEnabled true &#125; 添加上面配置会在apk中生成读个dex文件]]></content>
  </entry>
  <entry>
    <title><![CDATA[adb常用命令总结]]></title>
    <url>%2F2016%2F09%2F08%2Fadb%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[总结常用的adb命令 adb服务的开启与关闭1234//开启服务adb start-server//关闭服务adb stop-server 查看当前的机器列表1adb devices 程序的安装1adb install [apk 所在目录] 查看设备WIFI的MAC地址1adb shell cat /sys/class/net/wlan0/address 指定目标设备123adb -s &apos;serialNumber&apos; adb -d 指定当前唯一通过USB连接的Android设备adb -e 指定当前唯一运行的虚拟设备 进入手机1adb shell 切换到指定目录12cd data/data/包名/shared_prefsls 查看当前目录下的文件 查看相应包名的清单信息1adb shell dumpsys package[pkname] 安装应用1adb install [-lrtsdg] [apk 路径] 参数 作用 -l 将应用安装到保护目录/mnt/asec -r 允许覆盖安装 -t 允许安装 AndroidManifest.xml 里 application 指定 android:testOnly=”true” 的应用 -s 将应用安装到sdcard -d 允许覆盖降级安装 -g 授予所有运行时权限 如果包的签名咩有问题，在部分机器（如Lenovo K920）上扔会遇到[INSTALL_FAILED_VERIFICATION_FAILURE]安装失败的情况。解决方法如下： 将安装包复制到手机安装目录 adb push [xx.apk] /data/local/tmp/xx 安装apk adb shell pm install /data/local/tmp/xx 卸载应用1adb uninstall [pkname] 将设备文件拖到本地1adb pull [手机文件目录] [电脑文件目录] 将本地文件拖到设备1adb push [电脑文件路径] [手机文件目录] 清空应用缓存1adb shell pm clear [pkname] 查看debug包的沙盒数据12adb shellrun-as [pkname] 获取屏幕的分辨率12adb shell wm size//屏幕分辨率adb shell wm density//屏幕密度 查看安装的程序12345adb shell pm list packages //添加过滤参数adb shell pm list packages -s//获取系统应用adb shell pm list packages -3//第三方应用adb shell pm list packages &apos;过滤字段&apos; 传输文件12adb push &lt;要发送的文件路径&gt; &lt;发送到的路径&gt;adb push test.text sdcard/Movies 屏幕截图123456// 截屏并保存到电脑的当前目录adb exec-out screencap -p &gt; picture_name.png// 截屏并保存到当前设备adb shell screencap -p /sdcard/sc.png 模拟屏幕滑动1adb shell input swipe [startX、startY、endX、endY、durationTime(ms)]]]></content>
      <tags>
        <tag>Android</tag>
        <tag>adb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AndroidStudio使用中遇到的问题]]></title>
    <url>%2F2016%2F08%2F17%2FAndroidStudio%E4%BD%BF%E7%94%A8%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[关于AndroidStudio布局文件的预览问题 布局预览问题今天打开AndroidStudio突然发现布局文件没有了预览，显示是这个样子的：后来发现发现是自己下载了API24的SDK Platform，AS在预览是会自动选择本地最新版的SDK版本。好了，那么解决问题的方法就是把预览的版本调低就可以了。åç 效果如下]]></content>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AS打没签名的APK包]]></title>
    <url>%2F2016%2F08%2F16%2FAS%E6%89%93%E6%B2%A1%E7%AD%BE%E5%90%8D%E7%9A%84APK%E5%8C%85%2F</url>
    <content type="text"><![CDATA[没有签名的apk是无法安装到手机上正常使用的，AS在每次打包发布时如果没有配置签名系统都会使用默认的debug签名来保证程序的正常运行。那么问题来了，打个unSignApk有啥用？呵呵！确实没啥卵用，就是自己己玩玩儿。]]></content>
      <tags>
        <tag>AndroidStudio</tag>
      </tags>
  </entry>
</search>
